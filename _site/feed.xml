<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-02T15:28:06+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gregor Riegler</title><subtitle>merciless refactorer</subtitle><author><name>Gregor Riegler</name></author><entry><title type="html">testing a legacy cli app</title><link href="http://localhost:4000/2020/01/01/testing-legacy-cli.html" rel="alternate" type="text/html" title="testing a legacy cli app" /><published>2020-01-01T00:00:00+01:00</published><updated>2020-01-01T00:00:00+01:00</updated><id>http://localhost:4000/2020/01/01/testing-legacy-cli</id><content type="html" xml:base="http://localhost:4000/2020/01/01/testing-legacy-cli.html">&lt;p&gt;Adding characterization tests to a legacy java code command line application. Running into the legacy code dilemma because of dependencies to the System global.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/qHGc373a998&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/redirect?q=https%3A%2F%2Fgithub.com%2Fgregorriegler%2Fcoffeemachine-kata&amp;amp;redir_token=xioPUXrgmPu_YF2dTvJ1FPIbqVh8MTU3Nzk4NjEzNEAxNTc3ODk5NzM0&amp;amp;event=video_description&amp;amp;v=qHGc373a998&quot;&gt;The code on my GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I found the code thanks to &lt;a href=&quot;https://www.twitch.tv/jitterted&quot;&gt;Ted Young&lt;/a&gt;, check out his quality coding twitch stream.&lt;/p&gt;

&lt;p&gt;Where the code originates from: &lt;a href=&quot;https://codereview.stackexchange.com/questions/83135/designing-a-coffee-machine&quot;&gt;stackexchange post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Recommended book: &lt;a href=&quot;https://wiki.c2.com/?WorkingEffectivelyWithLegacyCode&quot;&gt;Working Effectively With Legacy Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Recommended talk: &lt;a href=&quot;https://www.youtube.com/watch?v=4cVZvoFGJTU&quot;&gt;Michael Feathers - the deep synergy between testability and good design.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The 3rd party lib i used for Characterization Testing: &lt;a href=&quot;https://github.com/gregorriegler/seamer&quot;&gt;Seamer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Post about &lt;a href=&quot;https://martinfowler.com/articles/preparatory-refactoring-example.html&quot;&gt;Preparatory Refactoring&lt;/a&gt;.&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">Adding characterization tests to a legacy java code command line application. Running into the legacy code dilemma because of dependencies to the System global.</summary></entry><entry><title type="html">embellishment to decorator</title><link href="http://localhost:4000/2019/12/17/embellishment-to-decorator.html" rel="alternate" type="text/html" title="embellishment to decorator" /><published>2019-12-17T00:00:00+01:00</published><updated>2019-12-17T00:00:00+01:00</updated><id>http://localhost:4000/2019/12/17/embellishment-to-decorator</id><content type="html" xml:base="http://localhost:4000/2019/12/17/embellishment-to-decorator.html">&lt;p&gt;Moving a cross cutting concern to a decorator can improve flexibility and at the same time reduce complexity of the subject.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/jaIk2j_vCWo&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/refactoring-embellishment-to-decorator&quot;&gt;the code on my GitHub&lt;/a&gt;&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">Moving a cross cutting concern to a decorator can improve flexibility and at the same time reduce complexity of the subject.</summary></entry><entry><title type="html">lift up conditional</title><link href="http://localhost:4000/2019/12/08/lift-up-conditional.html" rel="alternate" type="text/html" title="lift up conditional" /><published>2019-12-08T00:00:00+01:00</published><updated>2019-12-08T00:00:00+01:00</updated><id>http://localhost:4000/2019/12/08/lift-up-conditional</id><content type="html" xml:base="http://localhost:4000/2019/12/08/lift-up-conditional.html">&lt;p&gt;The lift up conditional refactoring is useful for complex and deeply nested conditionals, where related parts are scattered all over the place.
I am using the Gilded Rose Kata, which is a perfect example, as it consists of a really complex conditional.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/0bhfWtZocF8&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/GildedRose-Refactoring-Kata/tree/lift-up-if-refactoring/Java&quot;&gt;the code on my GitHub&lt;/a&gt;&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">The lift up conditional refactoring is useful for complex and deeply nested conditionals, where related parts are scattered all over the place. I am using the Gilded Rose Kata, which is a perfect example, as it consists of a really complex conditional.</summary></entry><entry><title type="html">conditional to polymorphism</title><link href="http://localhost:4000/2019/12/02/conditional-to-polymorphism.html" rel="alternate" type="text/html" title="conditional to polymorphism" /><published>2019-12-02T00:00:00+01:00</published><updated>2019-12-02T00:00:00+01:00</updated><id>http://localhost:4000/2019/12/02/conditional-to-polymorphism</id><content type="html" xml:base="http://localhost:4000/2019/12/02/conditional-to-polymorphism.html">&lt;p&gt;A conditional, like a switch statement can sometimes be fraudulent. 
It appears to be a nice and simple solution when it is in fact hiding and provoking duplication.
By refactoring to polymorphism we adhere to the ‘Tell Don’t Ask’ principle and get rid of the duplicated parts.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/YEPaGWYkL74&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/refactoring-conditional-to-polymorphism&quot;&gt;the code on my GitHub&lt;/a&gt;&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">A conditional, like a switch statement can sometimes be fraudulent. It appears to be a nice and simple solution when it is in fact hiding and provoking duplication. By refactoring to polymorphism we adhere to the ‘Tell Don’t Ask’ principle and get rid of the duplicated parts.</summary></entry><entry><title type="html">extract value object</title><link href="http://localhost:4000/2019/11/24/extract-value-object.html" rel="alternate" type="text/html" title="extract value object" /><published>2019-11-24T00:00:00+01:00</published><updated>2019-11-24T00:00:00+01:00</updated><id>http://localhost:4000/2019/11/24/extract-value-object</id><content type="html" xml:base="http://localhost:4000/2019/11/24/extract-value-object.html">&lt;p&gt;A value object is a reusable, immutable object that does not only encapsulate a primitive value, but also its behaviour.
Identifying and extracting those value objects improve the cohesion in our code, and avoids duplication.
Suppose i created a new component that consumed an already existing value object, i would be able to reuse the values methods instead of implementing duplicated code by accident.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/xLSJk1OcAhA&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/refactoring-extract-value-object&quot;&gt;the code on my GitHub&lt;/a&gt;&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">A value object is a reusable, immutable object that does not only encapsulate a primitive value, but also its behaviour. Identifying and extracting those value objects improve the cohesion in our code, and avoids duplication. Suppose i created a new component that consumed an already existing value object, i would be able to reuse the values methods instead of implementing duplicated code by accident.</summary></entry><entry><title type="html">split phase</title><link href="http://localhost:4000/2019/11/24/split-phase.html" rel="alternate" type="text/html" title="split phase" /><published>2019-11-24T00:00:00+01:00</published><updated>2019-11-24T00:00:00+01:00</updated><id>http://localhost:4000/2019/11/24/split-phase</id><content type="html" xml:base="http://localhost:4000/2019/11/24/split-phase.html">&lt;p&gt;In a split phase refactoring, we split a tangled piece of code that does more than one thing into distinguished phases that only do a single thing.
As a result we can more easily and independently change each of the resulting phases.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/sIceCgI6QO0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/refactoring-split-phase&quot;&gt;the code on my GitHub&lt;/a&gt;&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html">In a split phase refactoring, we split a tangled piece of code that does more than one thing into distinguished phases that only do a single thing. As a result we can more easily and independently change each of the resulting phases.</summary></entry><entry><title type="html">shower thoughts on agility</title><link href="http://localhost:4000/2019/10/08/shower-thought-why-agile-works.html" rel="alternate" type="text/html" title="shower thoughts on agility" /><published>2019-10-08T00:00:00+02:00</published><updated>2019-10-08T00:00:00+02:00</updated><id>http://localhost:4000/2019/10/08/shower-thought-why-agile-works</id><content type="html" xml:base="http://localhost:4000/2019/10/08/shower-thought-why-agile-works.html">&lt;h2 id=&quot;unexpected&quot;&gt;unexpected&lt;/h2&gt;

&lt;p&gt;we've seen developers writing unit tests, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers writing those unit tests before writing any production code, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers spending time in improving the code, without getting any new feature done, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers doing pair programming - costing twice as much to solve the same problem? - and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers doing mob programming, having a small group of people working at the same time, on the same problem and on the same computer, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers spending their work time in learning and practice, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers quit doing estimates, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we've seen developers managing to deliver useful versions early and often.&lt;/p&gt;
&lt;p&gt;we've seen developers managing to deliver value to their customers every single day.&lt;/p&gt;
&lt;p&gt;we've seen organizations giving power to their development teams, and it has worked out well for them.&lt;/p&gt;
&lt;p&gt;we didn't expect those things to work out this way - yet here we are.&lt;/p&gt;

&lt;p&gt;this is very refreshing in my opinion, and i am very interested in exploring why those things worked out the way they did.&lt;br /&gt;
it seems like we really suck at predicting what would work and what wouldn’t.&lt;br /&gt;
but if we are so bad at those predictions, shouldn’t we just try things out?&lt;/p&gt;

&lt;h2 id=&quot;the-industrial-age&quot;&gt;the industrial age&lt;/h2&gt;
&lt;p&gt;first of all, i believe that our thinking has been stuck in the industrial age of &lt;a href=&quot;https://en.wikipedia.org/wiki/Frederick_Winslow_Taylor&quot;&gt;taylorism&lt;/a&gt; and militarism, and that these ideas have shaped our way of thinking, teaching, working and just everything, up until today.
taylorism might have worked well in factories, where every new produced thing was exactly the same, and it was finished at some point.
this however seems not to be the case with software.
software is never the same, and if it was you’d reuse it.
software is never finished, it keeps changing and improving.
software development is just fundamentally different to factory work.
it is about knowledge, communication, experimentation, discovery and learning.&lt;/p&gt;

&lt;h2 id=&quot;knowledge-refineries&quot;&gt;knowledge refineries&lt;/h2&gt;
&lt;p&gt;software starts with somebody having a need.
this need unfolds in an idea, a vision.
in a traditional world this vision leads to the creation of requirements.
the requirements are used to create specifications.
the specifications guide the writing of the code.
each of these steps could be seen as refinements of knowledge.
the knowledge starts very vague and becomes gradually more specific until it ends in code.
the knowledge is transferred, refined, stored, and it decays (thanks to Alex Bolboacă &lt;a href=&quot;https://twitter.com/alexboly&quot;&gt;@alexboly&lt;/a&gt; for this &lt;a href=&quot;https://mozaicworks.com/blog/software-engineering/knowledge-refinery/&quot;&gt;observation&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;the-risk-of-bugs&quot;&gt;the risk of bugs&lt;/h2&gt;
&lt;p&gt;in a traditional world, those refinements are done by different people of different skills with distance among them.
we know that communication is lossy, and that the devil is in the details.
needs are often lost in communication, resulting in instructions without context.
instructions without context are likely the source of speculative assumptions.
bugs may not only occur in code, but in specification, requirements, and ideas as well.
thus each refinement step has a risk of bugs.
the amount of people involved, and the distance between those people increase the risk of bugs.
the amount of refinement steps in the process, and the length of interval between them, increase the risk of bugs.
the damage of bugs in early stages of the development process grows if left undiscovered.
the damage of bugs is reduced when the code is in a maintainable state.
one way to discover bugs early, and to prevent them from doing lots of damage, is continuous feedback.
the faster the feedback, the smaller the risk.
a waterfall process hides bugs until the last possible moment, it maximizes the risk of bugs, and the damage those bugs inflict.&lt;/p&gt;

&lt;h2 id=&quot;code-as-a-byproduct&quot;&gt;code as a byproduct&lt;/h2&gt;
&lt;p&gt;if software development is so much about discovering bugs, maybe code is just a byproduct.
the real product would be the learning, and the discovery of a bug-free vision.&lt;/p&gt;

&lt;h2 id=&quot;the-many-minds-problem&quot;&gt;the many minds problem&lt;/h2&gt;
&lt;p&gt;too many cooks spoil the broth, and it’s the same with code.
different programmers have different opinions, styles and knowledge.
many disconnected minds working on the same system can only make it unnecessarily complex.
code is duplicated, when the existing implementation is not known or disliked.
styles of design in areas of the code deviate from one another.
programmers of all levels of experience have a hard time creating quality output, while quality output has a lot of attributes.
mob programming helps solving these issues in an attempt to create a single mind of many.&lt;/p&gt;

&lt;h2 id=&quot;storing-knowledge&quot;&gt;storing knowledge&lt;/h2&gt;
&lt;p&gt;storing knowledge in brains is risky as brains are bad at remembering details.
knowledge stored in just a single brain is even more risky, as it gets lost in fluctuation (&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_factor&quot;&gt;bus factor&lt;/a&gt;).
documentation quickly becomes dated. facts change, but no one updates the documentation.
the only trustworthy long term store for knowledge is the code, as it never gets old. same with executable specification in the form of tests that change with the code.&lt;/p&gt;

&lt;h2 id=&quot;transferring-knowledge-meetings&quot;&gt;transferring knowledge: meetings&lt;/h2&gt;
&lt;p&gt;when programmers get in the zone, their short-term memories become stuffed with details about a specific problem and the code.
meetings often cause damage by tearing programmers out of this context, which took a long time to setup in the first place.
to make things worse, the details discussed in those meetings are typically unrelated to the programmers recent context.
so, not only will the programmer spend a lot of time getting back into the zone after the meeting, also parts of the knowledge gained within the meeting will get lost in that process anyhow.&lt;/p&gt;

&lt;h2 id=&quot;transferring-knowledge-email&quot;&gt;transferring knowledge: email&lt;/h2&gt;
&lt;p&gt;a good way to avoid lossy communication is to have the recipient repeat in their own words what they have understood.
the sender then has immediate feedback if there was a misunderstanding or not.
email does not provide this way of feedback, it is typically ‘send and forget’, sometimes even disregarded.&lt;/p&gt;

&lt;h2 id=&quot;knowledge-refactoring&quot;&gt;knowledge refactoring&lt;/h2&gt;
&lt;p&gt;refactoring is a vital practice to make code more comprehensible, and to discover bugs.
but what about requirements and specification?
if they are similar to code, just not as refined - shouldn’t we refactor them, too?&lt;/p&gt;

&lt;h2 id=&quot;estimation&quot;&gt;estimation&lt;/h2&gt;
&lt;p&gt;the things we estimate are typically not the things that cause most of our effort.
the things we estimate are naturally known things.
but it is about the things we don’t know, that make the effort.&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Does this seem about right? &lt;a href=&quot;https://t.co/PEtgTBX9eM&quot;&gt;pic.twitter.com/PEtgTBX9eM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oluf Nissen (@GeekTieGuy) &lt;a href=&quot;https://twitter.com/GeekTieGuy/status/1176895878478450688?ref_src=twsrc%5Etfw&quot;&gt;September 25, 2019&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;derived-principles&quot;&gt;derived principles?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;less people involved -&amp;gt; smaller teams.&lt;/li&gt;
  &lt;li&gt;less distance between people.&lt;/li&gt;
  &lt;li&gt;write code together.&lt;/li&gt;
  &lt;li&gt;continuous collaboration, share knowledge.&lt;/li&gt;
  &lt;li&gt;continuous and fast feedback using smaller batches.&lt;/li&gt;
  &lt;li&gt;idea to code as soon as possible.&lt;/li&gt;
  &lt;li&gt;avoid meetings and emails.&lt;/li&gt;
  &lt;li&gt;avoid estimation.&lt;/li&gt;
  &lt;li&gt;have the courage to question input.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Gregor Riegler</name></author><category term="agile" /><summary type="html">unexpected we've seen developers writing unit tests, and it has worked out well for them. we've seen developers writing those unit tests before writing any production code, and it has worked out well for them. we've seen developers spending time in improving the code, without getting any new feature done, and it has worked out well for them. we've seen developers doing pair programming - costing twice as much to solve the same problem? - and it has worked out well for them. we've seen developers doing mob programming, having a small group of people working at the same time, on the same problem and on the same computer, and it has worked out well for them. we've seen developers spending their work time in learning and practice, and it has worked out well for them. we've seen developers quit doing estimates, and it has worked out well for them. we've seen developers managing to deliver useful versions early and often. we've seen developers managing to deliver value to their customers every single day. we've seen organizations giving power to their development teams, and it has worked out well for them. we didn't expect those things to work out this way - yet here we are. this is very refreshing in my opinion, and i am very interested in exploring why those things worked out the way they did. it seems like we really suck at predicting what would work and what wouldn’t. but if we are so bad at those predictions, shouldn’t we just try things out? the industrial age first of all, i believe that our thinking has been stuck in the industrial age of taylorism and militarism, and that these ideas have shaped our way of thinking, teaching, working and just everything, up until today. taylorism might have worked well in factories, where every new produced thing was exactly the same, and it was finished at some point. this however seems not to be the case with software. software is never the same, and if it was you’d reuse it. software is never finished, it keeps changing and improving. software development is just fundamentally different to factory work. it is about knowledge, communication, experimentation, discovery and learning. knowledge refineries software starts with somebody having a need. this need unfolds in an idea, a vision. in a traditional world this vision leads to the creation of requirements. the requirements are used to create specifications. the specifications guide the writing of the code. each of these steps could be seen as refinements of knowledge. the knowledge starts very vague and becomes gradually more specific until it ends in code. the knowledge is transferred, refined, stored, and it decays (thanks to Alex Bolboacă @alexboly for this observation). the risk of bugs in a traditional world, those refinements are done by different people of different skills with distance among them. we know that communication is lossy, and that the devil is in the details. needs are often lost in communication, resulting in instructions without context. instructions without context are likely the source of speculative assumptions. bugs may not only occur in code, but in specification, requirements, and ideas as well. thus each refinement step has a risk of bugs. the amount of people involved, and the distance between those people increase the risk of bugs. the amount of refinement steps in the process, and the length of interval between them, increase the risk of bugs. the damage of bugs in early stages of the development process grows if left undiscovered. the damage of bugs is reduced when the code is in a maintainable state. one way to discover bugs early, and to prevent them from doing lots of damage, is continuous feedback. the faster the feedback, the smaller the risk. a waterfall process hides bugs until the last possible moment, it maximizes the risk of bugs, and the damage those bugs inflict. code as a byproduct if software development is so much about discovering bugs, maybe code is just a byproduct. the real product would be the learning, and the discovery of a bug-free vision. the many minds problem too many cooks spoil the broth, and it’s the same with code. different programmers have different opinions, styles and knowledge. many disconnected minds working on the same system can only make it unnecessarily complex. code is duplicated, when the existing implementation is not known or disliked. styles of design in areas of the code deviate from one another. programmers of all levels of experience have a hard time creating quality output, while quality output has a lot of attributes. mob programming helps solving these issues in an attempt to create a single mind of many. storing knowledge storing knowledge in brains is risky as brains are bad at remembering details. knowledge stored in just a single brain is even more risky, as it gets lost in fluctuation (bus factor). documentation quickly becomes dated. facts change, but no one updates the documentation. the only trustworthy long term store for knowledge is the code, as it never gets old. same with executable specification in the form of tests that change with the code. transferring knowledge: meetings when programmers get in the zone, their short-term memories become stuffed with details about a specific problem and the code. meetings often cause damage by tearing programmers out of this context, which took a long time to setup in the first place. to make things worse, the details discussed in those meetings are typically unrelated to the programmers recent context. so, not only will the programmer spend a lot of time getting back into the zone after the meeting, also parts of the knowledge gained within the meeting will get lost in that process anyhow. transferring knowledge: email a good way to avoid lossy communication is to have the recipient repeat in their own words what they have understood. the sender then has immediate feedback if there was a misunderstanding or not. email does not provide this way of feedback, it is typically ‘send and forget’, sometimes even disregarded. knowledge refactoring refactoring is a vital practice to make code more comprehensible, and to discover bugs. but what about requirements and specification? if they are similar to code, just not as refined - shouldn’t we refactor them, too? estimation the things we estimate are typically not the things that cause most of our effort. the things we estimate are naturally known things. but it is about the things we don’t know, that make the effort. Does this seem about right? pic.twitter.com/PEtgTBX9eM&amp;mdash; Oluf Nissen (@GeekTieGuy) September 25, 2019 derived principles? less people involved -&amp;gt; smaller teams. less distance between people. write code together. continuous collaboration, share knowledge. continuous and fast feedback using smaller batches. idea to code as soon as possible. avoid meetings and emails. avoid estimation. have the courage to question input.</summary></entry><entry><title type="html">Who Needs Lombok Anyhow</title><link href="http://localhost:4000/2019/08/10/who-needs-lombok-anyhow.html" rel="alternate" type="text/html" title="Who Needs Lombok Anyhow" /><published>2019-08-10T00:00:00+02:00</published><updated>2019-08-10T00:00:00+02:00</updated><id>http://localhost:4000/2019/08/10/who-needs-lombok-anyhow</id><content type="html" xml:base="http://localhost:4000/2019/08/10/who-needs-lombok-anyhow.html">&lt;p&gt;Java is quite a verbose language and annotations can solve almost any problem.
Right? - What a dangerous combination that is.&lt;/p&gt;

&lt;p&gt;I understand it, totally. I’m lazy too.
But other than saving all that boilerplate, have you considered the repercussions?&lt;/p&gt;

&lt;h3 id=&quot;magic-is-harmful&quot;&gt;Magic is harmful&lt;/h3&gt;
&lt;p&gt;I don’t want any magic in my code. 
It is the thing that makes behaviour non-transparent.
It makes you fire up your debugger, because you don’t actually understand what is going on behind the scenes.
There should be no &lt;em&gt;behind the scenes&lt;/em&gt;.
Everything should be as explicit as possible, for economic reasons.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Magic is a feature with non-compositional semantics that succeeds in making the common case easy, at the cost of making the uncommon cases surprising, impossible, or ridiculously complex.&lt;/p&gt;

  &lt;p&gt;~ John A De Goes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;data-getter-and-setter-are-a-design-smell&quot;&gt;@Data, @Getter and @Setter are a design smell&lt;/h3&gt;
&lt;p&gt;When i design the objects of my domain i want to avoid accessors.
I want those objects to represent a set of behaviours on nicely encapsulated data. 
I’ll occasionally have some public fields on my &lt;em&gt;Value Objects&lt;/em&gt;, but that’s about it. 
Why would i want getters or setters on these objects? They are a backdoor to the data that ought to be modified through specific methods. 
This smells like &lt;a href=&quot;https://refactoring.guru/smells/feature-envy&quot;&gt;Feature Envy&lt;/a&gt; and &lt;a href=&quot;https://martinfowler.com/bliki/AnemicDomainModel.html&quot;&gt;Anemic Domain Model&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also, setters work against my intention of making most of my objects immutable.
After all, immutable objects are easier to refactor.&lt;/p&gt;

&lt;p&gt;So where do i need accessors then?
Maybe on my data transfer objects?
Why would i want to go the length of making fields private and creating accessors on a structure that is solely data?
Does this kind of information hiding provide &lt;em&gt;any&lt;/em&gt; value? To me, it is just clutter.
&lt;code class=&quot;highlighter-rouge&quot;&gt;public final&lt;/code&gt; fields without accessors are a much cleaner solution here imho.
And there i am, left without a need for accessors.&lt;/p&gt;

&lt;h3 id=&quot;allargsconstructor-introduces-connascence-of-position&quot;&gt;@AllArgsConstructor introduces connascence of position&lt;/h3&gt;
&lt;p&gt;This awful annotation couples the order of your fields to the order of its generated constructor arguments.
So when you reorder your fields, you effectively break your code.
That’s an awful &lt;a href=&quot;https://en.wikipedia.org/wiki/Connascence#Connascence_of_Position_(CoP)&quot;&gt;connascence of position&lt;/a&gt; right there.&lt;/p&gt;

&lt;h3 id=&quot;bi-directional-object-relations-cause-stack-overflows&quot;&gt;Bi-directional object relations cause stack overflows&lt;/h3&gt;
&lt;p&gt;So when you use Lomboks &lt;em&gt;equals&lt;/em&gt;, &lt;em&gt;hashCode&lt;/em&gt; or &lt;em&gt;toString&lt;/em&gt; implementations, it is interresting that bi-directional associations will cause a stack overflow.
I’m not saying bi-directional associations are desirable, or that those stack overflows aren’t obvious.
All I am saying is, that if Lombok was just a little bit smarter, it could probably have avoided those.&lt;/p&gt;

&lt;p&gt;The bad thing is not the stack overflow. It’s the fact that it is hidden behind an annotation.&lt;/p&gt;

&lt;h3 id=&quot;the-lombok-plugin-might-hit-your-cpu&quot;&gt;The Lombok plugin might hit your cpu&lt;/h3&gt;
&lt;p&gt;If you do use lombok annotations excessively and have a lot of pojos in your code base, the lombok plugin might hit your cpu.
I had one project where it caused the autocomplete drop down to load several seconds in specific areas of the code.
The problem was gone once i deactivated the plugin.
To be fair: Maybe it was just a temporary problem with the plugin that has already been addressed.&lt;/p&gt;

&lt;h3 id=&quot;compatibility-issues-with-java-versions-greater-than-8&quot;&gt;Compatibility issues with Java versions greater than 8&lt;/h3&gt;
&lt;p&gt;When i tried migrating a java 1.8 project that used lombok to java 11, i ran into issues.
And despite the &lt;a href=&quot;https://stackoverflow.com/questions/53866929/unable-to-use-lombok-with-java-11&quot;&gt;known issues&lt;/a&gt; and &lt;a href=&quot;https://github.com/rzwitserloot/lombok/issues/1723&quot;&gt;fixes&lt;/a&gt; that i found on the internet, i was not able to get it to work again within 2 hours of trying.
Delombok to the rescue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;update:&lt;/strong&gt; seems like i ran into a similar issue like &lt;a href=&quot;https://github.com/rzwitserloot/lombok/issues/1723&quot;&gt;this&lt;/a&gt;, trying to upgrade to java 11.&lt;/p&gt;

&lt;h2 id=&quot;without-lombok-what-are-the-alternatives&quot;&gt;Without lombok, what are the alternatives?&lt;/h2&gt;
&lt;p&gt;We can just fall back to explicit pojo code. Some libs, ide features and plugins will help us out with the boilerplate.&lt;/p&gt;

&lt;h3 id=&quot;equals-and-hashcode&quot;&gt;equals and hashcode&lt;/h3&gt;
&lt;p&gt;For value objects, where you want all fields included, the apache commons lang &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; come in handy.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public boolean equals(Object that) {
    return EqualsBuilder.reflectionEquals(this, that);
}
 
@Override
public int hashCode() {
    return HashCodeBuilder.reflectionHashCode(this);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;maybe even use an intellij live template like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public boolean equals(Object that) {
    return org.apache.commons.lang3.builder.EqualsBuilder.reflectionEquals(this, that);
}

@Override
public int hashCode() {
    return org.apache.commons.lang3.builder.HashCodeBuilder.reflectionHashCode(this);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;slf4j&quot;&gt;@Slf4j&lt;/h3&gt;
&lt;p&gt;I recommend using an intellij live template again.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// just put in 'className()' for the $CLASS$ variable
private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger($CLASS$.class);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/log_live_template.gif&quot; alt=&quot;Logger via live template&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;builder&quot;&gt;@Builder&lt;/h3&gt;
&lt;p&gt;I really like the builder generation plugins that are freely available on the intellij plugin market.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/7354-innerbuilder&quot;&gt;Inner Builder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/6585-builder-generator&quot;&gt;Builder Generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, there is a new &lt;a href=&quot;https://www.jetbrains.com/help/idea/replace-constructor-with-builder.html&quot;&gt;&lt;strong&gt;Replace Constructor with Builder&lt;/strong&gt;&lt;/a&gt; refactoring available now.
However, i prefer the &lt;strong&gt;Inner Builder&lt;/strong&gt; plugin.&lt;/p&gt;

&lt;h2 id=&quot;a-case-for-delombok&quot;&gt;A case for Delombok&lt;/h2&gt;
&lt;p&gt;Thankfully, there is this nice little feature called delombok.
It will transform all your former lombok annotations into the ugly boilerplate they created behind the scenes,
so you can completely get rid of it.
Don’t expect a beautiful outcome though, the generated code will contain a lot of &lt;code class=&quot;highlighter-rouge&quot;&gt;@SuppressWarnings(&quot;all&quot;)&lt;/code&gt;.
Also, the delombok feature of my intellij plugin caused my ide to freeze.
So i had to use the &lt;a href=&quot;http://anthonywhitford.com/lombok.maven/lombok-maven-plugin/usage.html&quot;&gt;Lombok Maven Plugin&lt;/a&gt; instead, it worked just fine.&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><summary type="html">Java is quite a verbose language and annotations can solve almost any problem. Right? - What a dangerous combination that is. I understand it, totally. I’m lazy too. But other than saving all that boilerplate, have you considered the repercussions? Magic is harmful I don’t want any magic in my code. It is the thing that makes behaviour non-transparent. It makes you fire up your debugger, because you don’t actually understand what is going on behind the scenes. There should be no behind the scenes. Everything should be as explicit as possible, for economic reasons. Magic is a feature with non-compositional semantics that succeeds in making the common case easy, at the cost of making the uncommon cases surprising, impossible, or ridiculously complex. ~ John A De Goes @Data, @Getter and @Setter are a design smell When i design the objects of my domain i want to avoid accessors. I want those objects to represent a set of behaviours on nicely encapsulated data. I’ll occasionally have some public fields on my Value Objects, but that’s about it. Why would i want getters or setters on these objects? They are a backdoor to the data that ought to be modified through specific methods. This smells like Feature Envy and Anemic Domain Model. Also, setters work against my intention of making most of my objects immutable. After all, immutable objects are easier to refactor. So where do i need accessors then? Maybe on my data transfer objects? Why would i want to go the length of making fields private and creating accessors on a structure that is solely data? Does this kind of information hiding provide any value? To me, it is just clutter. public final fields without accessors are a much cleaner solution here imho. And there i am, left without a need for accessors. @AllArgsConstructor introduces connascence of position This awful annotation couples the order of your fields to the order of its generated constructor arguments. So when you reorder your fields, you effectively break your code. That’s an awful connascence of position right there. Bi-directional object relations cause stack overflows So when you use Lomboks equals, hashCode or toString implementations, it is interresting that bi-directional associations will cause a stack overflow. I’m not saying bi-directional associations are desirable, or that those stack overflows aren’t obvious. All I am saying is, that if Lombok was just a little bit smarter, it could probably have avoided those. The bad thing is not the stack overflow. It’s the fact that it is hidden behind an annotation. The Lombok plugin might hit your cpu If you do use lombok annotations excessively and have a lot of pojos in your code base, the lombok plugin might hit your cpu. I had one project where it caused the autocomplete drop down to load several seconds in specific areas of the code. The problem was gone once i deactivated the plugin. To be fair: Maybe it was just a temporary problem with the plugin that has already been addressed. Compatibility issues with Java versions greater than 8 When i tried migrating a java 1.8 project that used lombok to java 11, i ran into issues. And despite the known issues and fixes that i found on the internet, i was not able to get it to work again within 2 hours of trying. Delombok to the rescue. update: seems like i ran into a similar issue like this, trying to upgrade to java 11. Without lombok, what are the alternatives? We can just fall back to explicit pojo code. Some libs, ide features and plugins will help us out with the boilerplate. equals and hashcode For value objects, where you want all fields included, the apache commons lang EqualsBuilder and HashCodeBuilder come in handy. @Override public boolean equals(Object that) { return EqualsBuilder.reflectionEquals(this, that); } @Override public int hashCode() { return HashCodeBuilder.reflectionHashCode(this); } maybe even use an intellij live template like this: @Override public boolean equals(Object that) { return org.apache.commons.lang3.builder.EqualsBuilder.reflectionEquals(this, that); } @Override public int hashCode() { return org.apache.commons.lang3.builder.HashCodeBuilder.reflectionHashCode(this); } @Slf4j I recommend using an intellij live template again. // just put in 'className()' for the $CLASS$ variable private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger($CLASS$.class); @Builder I really like the builder generation plugins that are freely available on the intellij plugin market. Inner Builder Builder Generator Also, there is a new Replace Constructor with Builder refactoring available now. However, i prefer the Inner Builder plugin. A case for Delombok Thankfully, there is this nice little feature called delombok. It will transform all your former lombok annotations into the ugly boilerplate they created behind the scenes, so you can completely get rid of it. Don’t expect a beautiful outcome though, the generated code will contain a lot of @SuppressWarnings(&quot;all&quot;). Also, the delombok feature of my intellij plugin caused my ide to freeze. So i had to use the Lombok Maven Plugin instead, it worked just fine.</summary></entry><entry><title type="html">seamer: a refactoring tool for java</title><link href="http://localhost:4000/2019/07/23/refactoring-tool-seamer.html" rel="alternate" type="text/html" title="seamer: a refactoring tool for java" /><published>2019-07-23T00:00:00+02:00</published><updated>2019-07-23T00:00:00+02:00</updated><id>http://localhost:4000/2019/07/23/refactoring-tool-seamer</id><content type="html" xml:base="http://localhost:4000/2019/07/23/refactoring-tool-seamer.html">&lt;p&gt;Just recently i was refactoring some very messy legacy java code and i stumbled upon this really long and complex method.
I had to refactor it but there were no tests, no safety net, what so ever. 
It had so many different paths that adding unit tests would have been a tedious endeavour.&lt;/p&gt;

&lt;p&gt;“Would be nice if had something like &lt;a href=&quot;https://github.com/testdouble/suture&quot;&gt;suture&lt;/a&gt;”, i thought.
So i decided to just code it real quick.&lt;/p&gt;

&lt;p&gt;Here is the result: &lt;a href=&quot;https://github.com/gregorriegler/seamer&quot;&gt;https://github.com/gregorriegler/seamer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Seamer is a refactoring tool for java that helps you get complex methods under test in order to make safe refactorings.&lt;/p&gt;

&lt;h3 id=&quot;how-does-it-work&quot;&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;Basically you just wrap a complex method with a lambda and the seamer will then record all your invocations including 
input arguments and return values, serialize and persist them. 
You can later replay those invocations to make sure everything still works.&lt;/p&gt;

&lt;p&gt;Seamer provides an api for you to make suggestions on the arguments you want to pass in. 
The tool will shuffle your suggestions and execute given arguments in all possible combinations.
Or you can just let it run, click around in your application, and record real values.&lt;/p&gt;

&lt;p&gt;When you are confident with the data you have recorded, go ahead and start your refactorings. 
Replay the seamer regularly to make sure everything still works.&lt;/p&gt;

&lt;p&gt;If you have ideas for further improvements, feel free to do so, or just make a pull request.&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="refactoring" /><category term="testing" /><category term="java" /><category term="seamer" /><summary type="html">Just recently i was refactoring some very messy legacy java code and i stumbled upon this really long and complex method. I had to refactor it but there were no tests, no safety net, what so ever. It had so many different paths that adding unit tests would have been a tedious endeavour. “Would be nice if had something like suture”, i thought. So i decided to just code it real quick. Here is the result: https://github.com/gregorriegler/seamer. Seamer is a refactoring tool for java that helps you get complex methods under test in order to make safe refactorings. How does it work? Basically you just wrap a complex method with a lambda and the seamer will then record all your invocations including input arguments and return values, serialize and persist them. You can later replay those invocations to make sure everything still works. Seamer provides an api for you to make suggestions on the arguments you want to pass in. The tool will shuffle your suggestions and execute given arguments in all possible combinations. Or you can just let it run, click around in your application, and record real values. When you are confident with the data you have recorded, go ahead and start your refactorings. Replay the seamer regularly to make sure everything still works. If you have ideas for further improvements, feel free to do so, or just make a pull request.</summary></entry><entry><title type="html">simplistic tdd setup for typescript with mocha and chai</title><link href="http://localhost:4000/2019/06/30/tdd-setup-typescript-mocha-chai.html" rel="alternate" type="text/html" title="simplistic tdd setup for typescript with mocha and chai" /><published>2019-06-30T00:00:00+02:00</published><updated>2019-06-30T00:00:00+02:00</updated><id>http://localhost:4000/2019/06/30/tdd-setup-typescript-mocha-chai</id><content type="html" xml:base="http://localhost:4000/2019/06/30/tdd-setup-typescript-mocha-chai.html">&lt;p&gt;i was doing a little bit of tdd in typescript recently and the setup always took me way too long. 
i was trying to do things right. i didn’t want any magic in my setup, everything i added should have a purpose. 
i wanted it to be simplistic but working. this is my outcome.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gregorriegler/tdd-setup-typescript-mocha-chai&quot;&gt;https://github.com/gregorriegler/tdd-setup-typescript-mocha-chai&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;feel free to use, or improve it.&lt;/p&gt;</content><author><name>Gregor Riegler</name></author><category term="TDD" /><category term="Typescript" /><category term="mocha" /><category term="chai" /><summary type="html">i was doing a little bit of tdd in typescript recently and the setup always took me way too long. i was trying to do things right. i didn’t want any magic in my setup, everything i added should have a purpose. i wanted it to be simplistic but working. this is my outcome. https://github.com/gregorriegler/tdd-setup-typescript-mocha-chai feel free to use, or improve it.</summary></entry></feed>