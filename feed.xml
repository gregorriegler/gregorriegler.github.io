<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://gregorriegler.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://gregorriegler.com/" rel="alternate" type="text/html" /><updated>2025-11-15T12:05:04+00:00</updated><id>http://gregorriegler.com/feed.xml</id><title type="html">Gregor Riegler</title><subtitle>Merciless Refactorer</subtitle><author><name>Gregor Riegler</name></author><entry><title type="html">Augmented Coding - A Pattern Language</title><link href="http://gregorriegler.com/2025/07/12/augmented-coding-pattern-language.html" rel="alternate" type="text/html" title="Augmented Coding - A Pattern Language" /><published>2025-07-12T00:00:00+00:00</published><updated>2025-07-12T00:00:00+00:00</updated><id>http://gregorriegler.com/2025/07/12/augmented-coding-pattern-language</id><content type="html" xml:base="http://gregorriegler.com/2025/07/12/augmented-coding-pattern-language.html"><![CDATA[<p>I was trying to get an LLM to perform TDD first when ChatGPT 3.5 was released in 2022. 
They added the possibility for the LLM to execute Python code back then. 
And you could create â€œGPTsâ€, agents that use your own system prompt kinda. 
Back then I created a <a href="https://chatgpt.com/g/g-MWGfe0UQn-software-crafter">Software Crafter GPT</a>. It could do simple katas. 
But its capabilities were limited. 
In the following months I did not witness a lot of improvement in the LLM space. 
It felt like stagnation and I was sceptical.</p>

<p>This changed in the recent months where I experienced successes with LLM-assisted development. 
It was fun, â€¦ addictive even.</p>

<p>Models and tooling have gotten better and actually useful for coding. 
There are still limitations, but itâ€™s good enough to try and get the most out of it.
I wanted to find out how much I can push up the autonomy slider while keeping up the quality and maintainability.
I spent a lot of time doing augmented coding, which to me meant to teach the agent what I would do.
This endeavour was so interesting that I had to describe some of the things I learned.</p>

<p>This post introduces a <em>pattern language</em> about some of the things that worked for me. 
I recently added examples. Some of them show a <em>demo run</em> using the <a href="https://github.com/gregorriegler/simple-agent">simple-agent</a>. 
Whenever you see a codeblock starting with <code class="language-plaintext highlighter-rouge">â¯ ./agent.sh</code> this is the simple agent.</p>

<h2 id="basics">Basics</h2>

<h3 id="-agent">ğŸ¤– Agent</h3>
<p><strong>Pattern:</strong> <em>Give the LLM Agency</em></p>

<p>An agent in its simplest form is nothing more than a loop that facilitates a dialog with a language model that allows it to execute tools. More advanced agents track context size, embed custom system prompts, provide different modes, let you choose the language model and do advanced context management. The agent is the engine of augmented work.</p>

<h3 id="-to-augment-oneself">ğŸ§  To Augment Oneself</h3>
<p><strong>Pattern:</strong> <em>Project what you are doing.</em></p>

<p>For me, augmentation is a learning process where we discover our habits, decisions and workflows and capture them into clear artifacts that are so precise that an agent can follow and thus imitate us. Before asking the agent to take action, pause to explore what you would do if you were doing it yourself. What steps would you take? What considerations matter? Describe that process to the agent. Externalize your own reasoning, step by step, so the agent can pick it up and run with it. Think of it as constructing a functional representation of yourself.
Often we have to go through the motions ourselves to surface unconscious decisions. In augmenting we learn about our own thinking and workflow. This process is an interresting shift in perspectives. It leads you to focus more on methodology and decision making rather than technical details. You have to be so clear about it, that things that were previously obvious but blurry, become well understood and formalized.</p>

<h2 id="-hateoag-hypertext-as-the-engine-of-agent-guidance">ğŸŒ <strong>HATEOAG</strong> (Hypertext as the Engine of Agent Guidance)</h2>

<p>Inspired by <a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>, this pattern treats hypertext as the driving mechanism for agent navigation and behavior. Hypertext guides the agent through a network of clearly defined, interlinked processes, memory, documentation files and code.</p>

<p>Links invite the agent to jump, read, and act.</p>

<h3 id="-starter-symbol">ğŸ“ Starter Symbol</h3>
<p><strong>Pattern:</strong> <em>Process Identity</em></p>

<p>Leading emojis are what LLMs are known for. You look at an article containing a lot of leading emojis and immediately think: <em>â€œGenerated!!â€</em> When the agent starts its message with an emoji, this symbol becomes a declaring header about the state of the process. It gives us feedback on where the agent is right nowâ€”and what it is doing.
Also, when itâ€™s missing, you know thereâ€™s something not quite right. Maybe the context has gotten too large, and itâ€™s drifting.
This is a lot of valuable feedback you receive just for a single character.
Guide the agent which starter symbol to use.</p>

<h4 id="starter-symbol-example-excerpt-from-rules-file">Starter Symbol example (excerpt from rules file)</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALWAYS start your answers with a STARTER_SYMBOL
The default STARTER_SYMBOL is ğŸ™
</code></pre></div></div>

<h3 id="-process-file">ğŸ“œ Process File</h3>
<p><strong>Pattern:</strong> <em>Externalize the task.</em></p>

<p>A <em>Process File</em> describes what the agent is supposed to do. It can live alongside your code or documentation, and it should link to all relevant information â€” source files, goals, constraints, etc.</p>

<p>A good Process File is small and focuses on a single thing.
It describes the high-level intent at first.
Then it lists all the steps the agent should follow in order to complete the task.</p>

<p>The natural and very convenient evolution of Process Files are <a href="https://docs.anthropic.com/en/docs/claude-code/slash-commands">slash commands</a>. They donâ€™t fully replace process files, but they can be a convenient entrypoint to a process.</p>

<h4 id="process-file-example-simple-taskmd">Process File example: <code class="language-plaintext highlighter-rouge">simple-task.md</code></h4>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STARTER_SYMBOL=âœ…

<span class="gh"># Simple Task</span>

Intent: Work on a small task while making sure the tests keep passing.
Make sure we don't accidentally add unwanted changes. 
<span class="p">
1.</span> Make sure the <span class="sb">`git status`</span> is clean and shows no changes.
<span class="p">2.</span> Make sure the tests pass before we start. Run <span class="sb">`test.sh`</span>.
<span class="p">3.</span> Execute the given Task.
<span class="p">4.</span> Make sure the tests pass again afterwards.
<span class="p">5.</span> Ask me to commit.
</code></pre></div></div>

<p>Start this process with the following prompt:</p>

<p><strong>Prompt:</strong> Read and follow <strong>@simple-task.md</strong>; the task is to delete all comments from the code.</p>

<h3 id="-subagent--subtask">ğŸªƒ Subagent / Subtask</h3>
<p><strong>Pattern:</strong> <em>Context engineering via delegation.</em></p>

<p>A Subagent is when the Agent starts another one with a fresh context to reduce the sizes of the context windows. Necessary information is passed through <a href="#-cross-context-memory">Cross-Context Memory</a> or prompt. Once completed, the Subagent summarizes its result and returns it to the initiator.</p>

<h4 id="subagent-example">Subagent example</h4>

<p><strong>Prompt:</strong> Start a subagent that says hello.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ ./agent.sh Start a subagent that says hello
Starting new session

Agent: I'll create a subagent with a simple task to say hello.
  ğŸ› ï¸ subagent Say hello to the user in a friendly way.

    Subagent: Let me create a friendly greeting message in a file.
      ğŸ› ï¸ create-file greeting.txt Hello! ğŸ‘‹
      Created file: greeting.txt with content

    Subagent: Let me show you the greeting I created.
      ğŸ› ï¸ cat greeting.txt
          1    Hello! ğŸ‘‹
</code></pre></div></div>

<h3 id="ï¸-taskchain">â›“ï¸ Taskchain</h3>
<p><strong>Pattern:</strong> <em>Link SubTasks together.</em></p>

<p>A Taskchain is a series of <a href="#-subagent--subtask">SubTasks</a> that call one another in sequence. Each task hands off to the next, forming a chain of autonomous steps that proceed even without user intervention. This leads to a long list of summaries in the end, as all tasks close only then.</p>

<h4 id="taskchain-example-test-first">Taskchain example: Test First</h4>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Write a failing Test</span>

STARTER_SYMBOL=ğŸ”´
<span class="p">
1.</span> Pick the next item from the testlist.
<span class="p">2.</span> Write the failing test
<span class="p">3.</span> Run the test and see it fail
<span class="p">4.</span> Start a subtask with the prompt 
   "Read and follow <span class="sb">`process/make-it-pass.md`</span>, the test is <span class="nt">&lt;testname&gt;</span>"
</code></pre></div></div>

<p>See how â€œWrite a failing Testâ€ links to <code class="language-plaintext highlighter-rouge">process/make-it-pass.md</code> in its fourth step.
It uses the <a href="#-subagent--subtask">Subagent pattern</a> to start a fresh context for this task.</p>

<h5 id="contents-of-processmake-it-passmd">Contents of process/make-it-pass.md</h5>
<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Make the failing test pass</span>

STARTER_SYMBOL=ğŸŸ¢
<span class="p">
1.</span> Run the tests, there should be exactly one failing test.
<span class="p">2.</span> Make the smallest possible change to the production code 
   to make the failing test and all other tests pass
<span class="p">3.</span> Run the tests, and see them pass
</code></pre></div></div>

<h3 id="-loop">ğŸ” Loop</h3>
<p><strong>Pattern:</strong> <em>Keep going.</em></p>

<p>A Loop is a Task or Task Chain that reinitiates itself. Its nature is recursive in order to maintain longer autonomy while preventing context drift. It typically progresses by changing <a href="#-cross-context-memory">Cross-Context Memory</a> across iterations, refining results or advancing through a workflow.</p>

<h4 id="loop-example-counter">Loop example: Counter</h4>

<h5 id="contents-of-countmd">Contents of count.md</h5>
<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span> Increment the prompted number by 1 and remember it as RESULT
<span class="p">-</span> Spawn a subagent with the prompt 
   "Read and follow <span class="sb">`count.md`</span>, start with the number <span class="nt">&lt;RESULT&gt;</span>"
</code></pre></div></div>

<h5 id="demo-run">Demo run</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ ./agent.sh read count.md and start with the number 1
Agent: Let me read the count.md file first.
Agent: Following the instructions:
  1. Starting number is 1
  2. Incrementing by 1: RESULT = 2
  3. Spawning subagent with the new number
  ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 2

  Subagent: Let me check the contents of count.md first.
  Subagent: The instructions tell me to:
    1. Increment 2 by 1, so RESULT = 3
    2. Spawn a subagent to continue counting with RESULT (3)
    ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 3

    Subagent: Let me check the contents of count.md first.
    Subagent: I'll follow the instructions:
      1. Starting number is 3
      2. Increment by 1: RESULT = 4
      3. Spawn a subagent with the specified prompt
      ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 4
...
Exiting...
</code></pre></div></div>

<h3 id="-condition">ğŸ”€ Condition</h3>
<p><strong>Pattern:</strong> <em>Fuzzy decision making.</em></p>

<p>Use natural language conditions to guide agent behavior. This can be rigid boolean logic, or very fuzzy. These conditions can be contextual and interpretive. They might be based on a <a href="#-state-indicator">State Indicator</a> or other implicit context state. This allows for a more human-like decision making in an automated processes.</p>

<h4 id="condition-example-stop-when-uncommitted-changes-are-detected">Condition example: Stop when uncommitted changes are detected.</h4>
<p>Lets take the Simple Task example from above and add a condition with step 2:</p>
<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="p">
1.</span> Make sure the <span class="sb">`git status`</span> is clean and shows no changes
<span class="p">2.</span> When there are any uncommitted changes, <span class="gs">**STOP**</span> immediately.
<span class="p">3.</span> Make sure the tests pass before we start. Run <span class="sb">`test.sh`</span>.

...
</code></pre></div></div>

<h3 id="ï¸-goto">â¡ï¸ Goto</h3>
<p><strong>Pattern:</strong> <em>Exit a loop, or just follow a different path.</em></p>

<p>Use a <a href="#-condition">condition</a> to determine whether to jump out of a <a href="#-loop">loop</a>. A loop may have several exits in different places based on different conditions.</p>

<h4 id="loop-example-count-til-10">Loop example: Count til 10</h4>

<h5 id="contents-of-countmd-1">Contents of count.md</h5>
<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">-</span> Increment the prompted number by 1 and remember it as RESULT
<span class="p">-</span> If the RESULT is 10 end.
<span class="p">-</span> If the RESULT is lower than 10 spawn a subagent with the prompt 
   "Read and follow <span class="sb">`count.md`</span>, start with the number <span class="nt">&lt;RESULT&gt;</span>"
</code></pre></div></div>

<h3 id="-orchestrator">ğŸ§­ Orchestrator</h3>
<p><strong>Pattern:</strong> <em>A guiding process launching the correct sub-processes in the right order.</em></p>

<p>An <em>Orchestrator</em> is a Process whose sole purpose is to initiate other processes using <a href="#-subagent--subtask">Subagent</a>, and to do so in the correct order. It acts as a conductor, calling out which <a href="#-process-file">Process File</a> should run next. It may use a State Machine to keep track of whatâ€™s been completed and what comes next.</p>

<h4 id="orchestrator-example-basic-refactoring">Orchestrator example: Basic Refactoring</h4>
<p>Each step is just creating another subagent and feeding the result into the next subagent.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Refactor</span>

STARTER_SYMBOL=ğŸ§¹
<span class="p">
1.</span> Initiate a new subtask to analyze the given code and 
   find a small step that improves its design. 
   Don't implement the change, just report back the 
   result of the analysis.
<span class="p">2.</span> Initiate a new subtask to decompose the proposed 
   design improvement to a plan of many small refactoring steps. 
   Each step should leave the code working. Don't execute yet, 
   just close the task reporting back the plan.
<span class="p">3.</span> Execute the planned refactoring steps, creating a new subtask 
   for each step where you run the tests before and after 
   the changes.
</code></pre></div></div>

<h3 id="-cross-context-memory">ğŸ’¾ Cross-Context Memory</h3>
<p><strong>Pattern:</strong> <em>Preserve memory between runs.</em></p>

<p>AI agents forget everything between contexts. Use Persistent Cross-Context Memory â€” a file or shared storage â€” to explicitly write down and reload facts, goals, decisions, and task progress. Treat this as the agentâ€™s long-term memory.</p>

<h4 id="example-goal-file">Example: Goal File</h4>

<p>When my development process is decomposed into several subagents doing their work, they need to be aligned on the overall goal, and the tasks that need to be done. We could define a <code class="language-plaintext highlighter-rouge">goal.md</code> file that provides at least a high level goal description, and a task list</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Goal: User can create an account</span>
<span class="p">
-</span> [x] Add a feature flag for the "create account" feature
<span class="p">-</span> [ ] Show button "create account" when the feature flag is turned on
<span class="p">-</span> [ ] When a user clicks on "create account" they see a simple form

...

</code></pre></div></div>

<h3 id="-state-indicator">ğŸš¦ State Indicator</h3>
<p><strong>Pattern:</strong> <em>Build a State Machine by memorizing where you are in the process.</em></p>

<p>We may track process state using a State Indicator and save it to the <a href="#-cross-context-memory">Cross-Context Memory</a>.
A simple State Indicator consists of a <a href="#-starter-symbol">Starter Symbol</a> and a descriptive keyword.
A more complicated one could span over many lines and contain structured information.
This enables resilient restarts from any point without losing that context.
The process of course needs to include steps to adapt the State Indicator.</p>

<h4 id="example-tdd-phases">Example: TDD Phases</h4>

<p>TDD is too large of a process for me to fit in a single process file.
So I have at least one <a href="#-subagent--subtask">subagent</a> for each of the phases.
To let the <a href="#-orchestrator">orchestrator</a> know where we are in the process, I use a state indicator.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="p">
1.</span> Look for the current TDD phase indicator in <span class="sb">`development.md`</span>:
<span class="p">   -</span> <span class="sb">`## TDD Phase: ğŸ”´`</span> - need to write a failing test
<span class="p">   -</span> <span class="sb">`## TDD Phase: ğŸŸ¢`</span> - need to make a test pass
<span class="p">   -</span> <span class="sb">`## TDD Phase: ğŸ§¹`</span> - need to refactor
<span class="p">2.</span> If no indicator is found, 
   default to ğŸ”´ and add <span class="sb">`## TDD Phase: ğŸ”´`</span> to <span class="sb">`development.md`</span>.
<span class="p">3.</span> Route to appropriate process:
<span class="p">   -</span> ğŸ”´: Create a subagent: "Follow <span class="sb">`process/write-a-failing-test.md`</span>"
<span class="p">   -</span> ğŸŸ¢: Create a subagent: "Follow <span class="sb">`process/make-it-pass.md`</span>"
<span class="p">   -</span> ğŸ§¹: Create a subagent: "Follow <span class="sb">`process/refactor.md`</span>"

...
</code></pre></div></div>

<h3 id="-statemachine-as-a-tool">ğŸ§° StateMachine as a Tool</h3>
<p><strong>Pattern:</strong> <em>Use a tool to drive the process.</em></p>

<p>State does not have to be just text, and a state machine does not have to be just a description of how the state may change. It can be a tool serving commands that describe the next possible actions and transitions, constraining the agent. This makes the tool a control mechanism.</p>

<h3 id="ï¸-dialog">ğŸ—£ï¸ Dialog</h3>
<p><strong>Pattern:</strong> <em>Interactive ideation.</em></p>

<p>For human-in-the-loop ideation, itâ€™s helpful to invite the agent to ask questions or critique ideas. Consider that the LLM has read the whole Internet. It knows things that we donâ€™t, and it is often helpful to leverage that.</p>

<h3 id="-wake">ğŸ”” Wake</h3>
<p><strong>Pattern:</strong> <em>Signal for attention.</em></p>

<p>Sometimes the Agent needs your input. Maybe it has a question, or it needs a review. Use a Signal step to make it speak up or play a sound â€” so you can focus on other things in the meantime.</p>

<h4 id="example-using-a-say-script">Example using a say script</h4>
<p>The say script runs some text to speech tool.
It is essentially a way for the agent to speak up.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">    -</span> Proceed only if all tests pass. 
      If they don't stop and notify me using <span class="sb">`./say.py`</span>
</code></pre></div></div>

<h2 id="evolving-the-process">Evolving the Process</h2>
<h3 id="-process-as-code">ğŸ“¦ Process as Code</h3>

<p><strong>Pattern:</strong> <em>Treat process definitions like code.</em>
Process definitions should be:</p>

<ul>
  <li>Version controlled</li>
  <li>Incrementally improved</li>
  <li>Tested through usage</li>
  <li>Refactored for clarity and smaller context</li>
  <li>Composed into larger workflows</li>
</ul>

<h3 id="ï¸-split-process">âœ‚ï¸ Split Process</h3>
<p><strong>Pattern:</strong> <em>Divide to prevent drift.</em></p>

<p>Long processes can lead to missing steps. 
Just as we do, agents seem to have limited cognitive capacity. 
The more context the agent has to hold in memory, the more likely it is to forget or skip parts of the process. 
The smaller and more focused the context, the more reliably the agent can follow through and perform. 
Decompose large processes into smaller ones, and track progress between them with explicit markers or checkpoints. Use <a href="#-cross-context-memory">Cross-Context Memory</a> to remember whatâ€™s necessary. 
This can be achieved by moving steps into another <a href="#-process-file">Process File</a> and using a <a href="#-subagent--subtask">Subtask</a> to invoke it from the original file. 
Another way to split the process is to put each piece into its own file and coordinate them with an <a href="#-orchestrator">Orchestrator</a>.</p>

<h3 id="ï¸-extract-coordinator">ğŸ›ï¸ Extract Coordinator</h3>
<p><strong>Pattern:</strong> <em>Pull coordination logic out of individual chain elements.</em></p>

<p>A <a href="#-taskchain">Task Chain</a> is a good starting point, but orchestration provides better control and maintainability.
The problem with Task Chains is that each element carries dual responsibility: performing its own work and managing the handoff to the next segment. This creates tight coupling and makes recovery complex.
We can separate these concerns by extracting the coordination responsibility into an <a href="#-orchestrator">Orchestrator</a>.
The individual segments then focus solely on their core work, while the orchestrator manages the sequence, and recovery logic from a single location.
Use a <a href="#-state-indicator">State Indicator</a> to track progress through the orchestrated workflow.</p>

<h3 id="-trial-run">ğŸ§ª Trial Run</h3>
<p><strong>Pattern:</strong> <em>Refine the process through practice.</em></p>

<p>Build a feature not for its own sake, but to test and refine the process. Then, throw the feature away. What did you learn? What went well? Adapt small things in the process and restart.</p>

<h3 id="-expose-decision">ğŸ§¾ Expose Decision</h3>
<p><strong>Pattern:</strong> <em>Make implicit context explicit.</em></p>

<p>As you evolve your workflows, make hidden, implicit context and decisions visible and explicit. Capture the state itâ€™s based on and make it persistent. Capture the decisions made and describe them. Explicit state and decisions make the process more resilient.</p>

<h2 id="what-works-well">What works well</h2>

<h3 id="-one-problem-at-a-time">ğŸªœ One problem at a time</h3>
<p><strong>Pattern:</strong> <em>Smaller is better. Refine the refined.</em></p>

<p>The LLM typically wants to perform too many changes and do too many things at once. It also tends to plan this way â€” no wonder, given the nature of its training data. To achieve better results, break big steps into smaller, clearer ones. And when youâ€™ve done that, take the smallest step and let the agent break it down even further. Always start with the tiniest one, and solve one problem at a time. Vertical slicing and TDD ZOMBIES have proven effective.</p>

<h3 id="-test-first">âœ… Test First</h3>
<p><strong>Pattern:</strong> <em>Start with the end in mind.</em></p>

<p>No production code without a failing test. This is now more obvious than ever. The agent needs all the feedback it can get. Make sure it doesnâ€™t break things, and keep the code running all the time.</p>

<h3 id="-hypothesize">ğŸ¤” Hypothesize</h3>
<p><strong>Pattern:</strong> <em>Have the agent state what it expects to happen.</em></p>

<p>The Agent is often wrong about a code change. When that happens, it will attempt to recover from the situation, taking several tries. These will inevitably contaminate the context. It may even lead to the agent giving up and making things worse by leaving unintended changes â€” often stating that it indeed solved the problem. I found it helpful to have the agent express its expectations about a code change first, before it runs the code. For example, before it runs a failing test, it can express what it expects to happen. This reinforces the actual intent in the context.</p>

<h3 id="-ask-dont-tell">â“ Ask, donâ€™t tell.</h3>
<p><strong>Pattern:</strong> <em>Keep the solution space open.</em></p>

<p>Donâ€™t tell the agent what to do, unless youâ€™re confident in the path forward. Consider that you might be wrong, or missing information. By telling it what to do, youâ€™re narrowing the solution space and leading the agent down a failure path.</p>

<p>Instead, leverage its knowledge.
Ask the right question to withdraw the relevant information into the context. Then use it, or store it in a relevant memory. This not only leads to better results â€” it creates a learning opportunity.</p>

<h3 id="-constraints">ğŸš§ Constraints</h3>
<p><strong>Pattern:</strong> <em>Keep it on a short leash.</em></p>

<p>The best way to help the agent avoid mistakes is to constrain what it can do. Instead of changing code freely, we can give it access to refactoring tools. We can lock it out of certain files or commands. Constraints are more than just rules â€” they shape what the agent can do or not do in its environment, enabling better and more reliable outputs.</p>

<h3 id="ï¸-refactor-guard">ğŸ›¡ï¸ Refactor Guard</h3>
<p><strong>Pattern:</strong> <em>Increase confidence in legacy code refactoring with micro ai code reviews.</em></p>

<p>When working in legacy code, make the smallest possible refactoring step, then let the Agent review and make sure that behavior hasnâ€™t changed. If the checks pass, it may even commit automatically. If it finds an issue it warns you.</p>

<h3 id="-stop">ğŸ«· Stop</h3>
<p><strong>Pattern:</strong> <em>Keep your finger on the stop button.</em></p>

<p>When the agent goes off the rails, for example when it does something it should not do, I like to stop it as quickly as I can.
The earlier I do that, the better.
I avoid contamination of the context and am more likely to help it recover without messing up the process.
I like to use <a href="#-ask-dont-tell">Ask, donâ€™t tell</a> when giving it recovery instructions.</p>

<h3 id="ï¸-algorithmify">âš™ï¸ Algorithmify</h3>
<p><strong>Pattern:</strong> <em>Automate whatever can be automated.</em></p>

<p>Favor algorithms over stochastic outputs to avoid mistakes and have the agent write its own automation. Itâ€™s really good at this. What is automated:</p>
<ul>
  <li>is deterministic.</li>
  <li>preserves cognitive capacity for other things.</li>
  <li>is often faster.</li>
</ul>

<p>Therefore, we want to automate as much as possible.</p>

<h3 id="-stdout-distillation">ğŸ’ Stdout Distillation</h3>
<p><strong>Pattern:</strong> <em>Reduce verbose output to essential signals.</em></p>

<p>The Stdout Distillation Pattern reduces verbose script output to only the essential information needed by an agent. Instead of flooding the context with logs, traces, or irrelevant details, the output is distilled into a concise signalâ€”such as a single line indicating success or failure. This minimizes context contamination, improves efficiency, and ensures the agent focuses only on what matters.</p>

<h4 id="example-a-testsh-script">Example: A test.sh script</h4>
<p>The script makes sure the test results are just a single line.
Only if the tests fail, more output is shown.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="nb">cd</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">!</span> <span class="nv">output</span><span class="o">=</span><span class="si">$(</span>python <span class="nt">-m</span> pytest tests/ <span class="nt">-v</span> 2&gt;&amp;1<span class="si">)</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$output</span><span class="s2">"</span>
    <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">passed_tests</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$output</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-c</span> <span class="s2">"PASSED"</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"0"</span><span class="si">)</span>
<span class="nb">echo</span> <span class="s2">"âœ… All </span><span class="nv">$passed_tests</span><span class="s2"> tests passed"</span>
</code></pre></div></div>

<h3 id="ï¸-cli-first">ğŸ–¥ï¸ CLI First</h3>
<p><strong>Pattern:</strong> <em>Let the agent thrive on the CLI.</em></p>

<p>Agent tooling should be CLI-first. The LLMâ€™s native medium is chat â€” text in, text out. This is exactly what the CLI was made for. On top of that, it offers many small, composable Unix-style tools. Agents thrive on the command line â€” give them tools there.</p>

<h2 id="conclusion">Conclusion</h2>
<p>I see a lot of â€œagileâ€ in the things that work well for me. Things like inspect and adapt, continuous improvement, small steps, iterate, TDD. The LLM is trained on and born into a waterfall world. When I look at the tooling people develop around it, and the things people do with it, I often see waterfall, too. And I see a lot of legacy code that will emerge. Maybe we can do better.</p>

<h2 id="influences--inspirations">Influences &amp; Inspirations</h2>

<p>It was LLewellyn Falco who first showed me the starter symbol as well as the output distillation pattern. The idea of <a href="https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes">Augmented Coding</a> was at first sparked by Kent Beck. I discovered subtasking through the usage of Roo Code which already had this feature.</p>]]></content><author><name>Gregor Riegler</name></author><category term="Augmented Coding" /><summary type="html"><![CDATA[I was trying to get an LLM to perform TDD first when ChatGPT 3.5 was released in 2022. They added the possibility for the LLM to execute Python code back then. And you could create â€œGPTsâ€, agents that use your own system prompt kinda. Back then I created a Software Crafter GPT. It could do simple katas. But its capabilities were limited. In the following months I did not witness a lot of improvement in the LLM space. It felt like stagnation and I was sceptical. This changed in the recent months where I experienced successes with LLM-assisted development. It was fun, â€¦ addictive even. Models and tooling have gotten better and actually useful for coding. There are still limitations, but itâ€™s good enough to try and get the most out of it. I wanted to find out how much I can push up the autonomy slider while keeping up the quality and maintainability. I spent a lot of time doing augmented coding, which to me meant to teach the agent what I would do. This endeavour was so interesting that I had to describe some of the things I learned. This post introduces a pattern language about some of the things that worked for me. I recently added examples. Some of them show a demo run using the simple-agent. Whenever you see a codeblock starting with â¯ ./agent.sh this is the simple agent. Basics ğŸ¤– Agent Pattern: Give the LLM Agency An agent in its simplest form is nothing more than a loop that facilitates a dialog with a language model that allows it to execute tools. More advanced agents track context size, embed custom system prompts, provide different modes, let you choose the language model and do advanced context management. The agent is the engine of augmented work. ğŸ§  To Augment Oneself Pattern: Project what you are doing. For me, augmentation is a learning process where we discover our habits, decisions and workflows and capture them into clear artifacts that are so precise that an agent can follow and thus imitate us. Before asking the agent to take action, pause to explore what you would do if you were doing it yourself. What steps would you take? What considerations matter? Describe that process to the agent. Externalize your own reasoning, step by step, so the agent can pick it up and run with it. Think of it as constructing a functional representation of yourself. Often we have to go through the motions ourselves to surface unconscious decisions. In augmenting we learn about our own thinking and workflow. This process is an interresting shift in perspectives. It leads you to focus more on methodology and decision making rather than technical details. You have to be so clear about it, that things that were previously obvious but blurry, become well understood and formalized. ğŸŒ HATEOAG (Hypertext as the Engine of Agent Guidance) Inspired by HATEOAS, this pattern treats hypertext as the driving mechanism for agent navigation and behavior. Hypertext guides the agent through a network of clearly defined, interlinked processes, memory, documentation files and code. Links invite the agent to jump, read, and act. ğŸ“ Starter Symbol Pattern: Process Identity Leading emojis are what LLMs are known for. You look at an article containing a lot of leading emojis and immediately think: â€œGenerated!!â€ When the agent starts its message with an emoji, this symbol becomes a declaring header about the state of the process. It gives us feedback on where the agent is right nowâ€”and what it is doing. Also, when itâ€™s missing, you know thereâ€™s something not quite right. Maybe the context has gotten too large, and itâ€™s drifting. This is a lot of valuable feedback you receive just for a single character. Guide the agent which starter symbol to use. Starter Symbol example (excerpt from rules file) ALWAYS start your answers with a STARTER_SYMBOL The default STARTER_SYMBOL is ğŸ™ ğŸ“œ Process File Pattern: Externalize the task. A Process File describes what the agent is supposed to do. It can live alongside your code or documentation, and it should link to all relevant information â€” source files, goals, constraints, etc. A good Process File is small and focuses on a single thing. It describes the high-level intent at first. Then it lists all the steps the agent should follow in order to complete the task. The natural and very convenient evolution of Process Files are slash commands. They donâ€™t fully replace process files, but they can be a convenient entrypoint to a process. Process File example: simple-task.md STARTER_SYMBOL=âœ… # Simple Task Intent: Work on a small task while making sure the tests keep passing. Make sure we don't accidentally add unwanted changes. 1. Make sure the `git status` is clean and shows no changes. 2. Make sure the tests pass before we start. Run `test.sh`. 3. Execute the given Task. 4. Make sure the tests pass again afterwards. 5. Ask me to commit. Start this process with the following prompt: Prompt: Read and follow @simple-task.md; the task is to delete all comments from the code. ğŸªƒ Subagent / Subtask Pattern: Context engineering via delegation. A Subagent is when the Agent starts another one with a fresh context to reduce the sizes of the context windows. Necessary information is passed through Cross-Context Memory or prompt. Once completed, the Subagent summarizes its result and returns it to the initiator. Subagent example Prompt: Start a subagent that says hello. â¯ ./agent.sh Start a subagent that says hello Starting new session Agent: I'll create a subagent with a simple task to say hello. ğŸ› ï¸ subagent Say hello to the user in a friendly way. Subagent: Let me create a friendly greeting message in a file. ğŸ› ï¸ create-file greeting.txt Hello! ğŸ‘‹ Created file: greeting.txt with content Subagent: Let me show you the greeting I created. ğŸ› ï¸ cat greeting.txt 1 Hello! ğŸ‘‹ â›“ï¸ Taskchain Pattern: Link SubTasks together. A Taskchain is a series of SubTasks that call one another in sequence. Each task hands off to the next, forming a chain of autonomous steps that proceed even without user intervention. This leads to a long list of summaries in the end, as all tasks close only then. Taskchain example: Test First # Write a failing Test STARTER_SYMBOL=ğŸ”´ 1. Pick the next item from the testlist. 2. Write the failing test 3. Run the test and see it fail 4. Start a subtask with the prompt "Read and follow `process/make-it-pass.md`, the test is &lt;testname&gt;" See how â€œWrite a failing Testâ€ links to process/make-it-pass.md in its fourth step. It uses the Subagent pattern to start a fresh context for this task. Contents of process/make-it-pass.md # Make the failing test pass STARTER_SYMBOL=ğŸŸ¢ 1. Run the tests, there should be exactly one failing test. 2. Make the smallest possible change to the production code to make the failing test and all other tests pass 3. Run the tests, and see them pass ğŸ” Loop Pattern: Keep going. A Loop is a Task or Task Chain that reinitiates itself. Its nature is recursive in order to maintain longer autonomy while preventing context drift. It typically progresses by changing Cross-Context Memory across iterations, refining results or advancing through a workflow. Loop example: Counter Contents of count.md - Increment the prompted number by 1 and remember it as RESULT - Spawn a subagent with the prompt "Read and follow `count.md`, start with the number &lt;RESULT&gt;" Demo run â¯ ./agent.sh read count.md and start with the number 1 Agent: Let me read the count.md file first. Agent: Following the instructions: 1. Starting number is 1 2. Incrementing by 1: RESULT = 2 3. Spawning subagent with the new number ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 2 Subagent: Let me check the contents of count.md first. Subagent: The instructions tell me to: 1. Increment 2 by 1, so RESULT = 3 2. Spawn a subagent to continue counting with RESULT (3) ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 3 Subagent: Let me check the contents of count.md first. Subagent: I'll follow the instructions: 1. Starting number is 3 2. Increment by 1: RESULT = 4 3. Spawn a subagent with the specified prompt ğŸ› ï¸ subagent Read and follow `count.md`, start with the number 4 ... Exiting... ğŸ”€ Condition Pattern: Fuzzy decision making. Use natural language conditions to guide agent behavior. This can be rigid boolean logic, or very fuzzy. These conditions can be contextual and interpretive. They might be based on a State Indicator or other implicit context state. This allows for a more human-like decision making in an automated processes. Condition example: Stop when uncommitted changes are detected. Lets take the Simple Task example from above and add a condition with step 2: ... 1. Make sure the `git status` is clean and shows no changes 2. When there are any uncommitted changes, **STOP** immediately. 3. Make sure the tests pass before we start. Run `test.sh`. ... â¡ï¸ Goto Pattern: Exit a loop, or just follow a different path. Use a condition to determine whether to jump out of a loop. A loop may have several exits in different places based on different conditions. Loop example: Count til 10 Contents of count.md - Increment the prompted number by 1 and remember it as RESULT - If the RESULT is 10 end. - If the RESULT is lower than 10 spawn a subagent with the prompt "Read and follow `count.md`, start with the number &lt;RESULT&gt;" ğŸ§­ Orchestrator Pattern: A guiding process launching the correct sub-processes in the right order. An Orchestrator is a Process whose sole purpose is to initiate other processes using Subagent, and to do so in the correct order. It acts as a conductor, calling out which Process File should run next. It may use a State Machine to keep track of whatâ€™s been completed and what comes next. Orchestrator example: Basic Refactoring Each step is just creating another subagent and feeding the result into the next subagent. # Refactor STARTER_SYMBOL=ğŸ§¹ 1. Initiate a new subtask to analyze the given code and find a small step that improves its design. Don't implement the change, just report back the result of the analysis. 2. Initiate a new subtask to decompose the proposed design improvement to a plan of many small refactoring steps. Each step should leave the code working. Don't execute yet, just close the task reporting back the plan. 3. Execute the planned refactoring steps, creating a new subtask for each step where you run the tests before and after the changes. ğŸ’¾ Cross-Context Memory Pattern: Preserve memory between runs. AI agents forget everything between contexts. Use Persistent Cross-Context Memory â€” a file or shared storage â€” to explicitly write down and reload facts, goals, decisions, and task progress. Treat this as the agentâ€™s long-term memory. Example: Goal File When my development process is decomposed into several subagents doing their work, they need to be aligned on the overall goal, and the tasks that need to be done. We could define a goal.md file that provides at least a high level goal description, and a task list # Goal: User can create an account - [x] Add a feature flag for the "create account" feature - [ ] Show button "create account" when the feature flag is turned on - [ ] When a user clicks on "create account" they see a simple form ... ğŸš¦ State Indicator Pattern: Build a State Machine by memorizing where you are in the process. We may track process state using a State Indicator and save it to the Cross-Context Memory. A simple State Indicator consists of a Starter Symbol and a descriptive keyword. A more complicated one could span over many lines and contain structured information. This enables resilient restarts from any point without losing that context. The process of course needs to include steps to adapt the State Indicator. Example: TDD Phases TDD is too large of a process for me to fit in a single process file. So I have at least one subagent for each of the phases. To let the orchestrator know where we are in the process, I use a state indicator. ... 1. Look for the current TDD phase indicator in `development.md`: - `## TDD Phase: ğŸ”´` - need to write a failing test - `## TDD Phase: ğŸŸ¢` - need to make a test pass - `## TDD Phase: ğŸ§¹` - need to refactor 2. If no indicator is found, default to ğŸ”´ and add `## TDD Phase: ğŸ”´` to `development.md`. 3. Route to appropriate process: - ğŸ”´: Create a subagent: "Follow `process/write-a-failing-test.md`" - ğŸŸ¢: Create a subagent: "Follow `process/make-it-pass.md`" - ğŸ§¹: Create a subagent: "Follow `process/refactor.md`" ... ğŸ§° StateMachine as a Tool Pattern: Use a tool to drive the process. State does not have to be just text, and a state machine does not have to be just a description of how the state may change. It can be a tool serving commands that describe the next possible actions and transitions, constraining the agent. This makes the tool a control mechanism. ğŸ—£ï¸ Dialog Pattern: Interactive ideation. For human-in-the-loop ideation, itâ€™s helpful to invite the agent to ask questions or critique ideas. Consider that the LLM has read the whole Internet. It knows things that we donâ€™t, and it is often helpful to leverage that. ğŸ”” Wake Pattern: Signal for attention. Sometimes the Agent needs your input. Maybe it has a question, or it needs a review. Use a Signal step to make it speak up or play a sound â€” so you can focus on other things in the meantime. Example using a say script The say script runs some text to speech tool. It is essentially a way for the agent to speak up. - Proceed only if all tests pass. If they don't stop and notify me using `./say.py` Evolving the Process ğŸ“¦ Process as Code Pattern: Treat process definitions like code. Process definitions should be: Version controlled Incrementally improved Tested through usage Refactored for clarity and smaller context Composed into larger workflows âœ‚ï¸ Split Process Pattern: Divide to prevent drift. Long processes can lead to missing steps. Just as we do, agents seem to have limited cognitive capacity. The more context the agent has to hold in memory, the more likely it is to forget or skip parts of the process. The smaller and more focused the context, the more reliably the agent can follow through and perform. Decompose large processes into smaller ones, and track progress between them with explicit markers or checkpoints. Use Cross-Context Memory to remember whatâ€™s necessary. This can be achieved by moving steps into another Process File and using a Subtask to invoke it from the original file. Another way to split the process is to put each piece into its own file and coordinate them with an Orchestrator. ğŸ›ï¸ Extract Coordinator Pattern: Pull coordination logic out of individual chain elements. A Task Chain is a good starting point, but orchestration provides better control and maintainability. The problem with Task Chains is that each element carries dual responsibility: performing its own work and managing the handoff to the next segment. This creates tight coupling and makes recovery complex. We can separate these concerns by extracting the coordination responsibility into an Orchestrator. The individual segments then focus solely on their core work, while the orchestrator manages the sequence, and recovery logic from a single location. Use a State Indicator to track progress through the orchestrated workflow. ğŸ§ª Trial Run Pattern: Refine the process through practice. Build a feature not for its own sake, but to test and refine the process. Then, throw the feature away. What did you learn? What went well? Adapt small things in the process and restart. ğŸ§¾ Expose Decision Pattern: Make implicit context explicit. As you evolve your workflows, make hidden, implicit context and decisions visible and explicit. Capture the state itâ€™s based on and make it persistent. Capture the decisions made and describe them. Explicit state and decisions make the process more resilient. What works well ğŸªœ One problem at a time Pattern: Smaller is better. Refine the refined. The LLM typically wants to perform too many changes and do too many things at once. It also tends to plan this way â€” no wonder, given the nature of its training data. To achieve better results, break big steps into smaller, clearer ones. And when youâ€™ve done that, take the smallest step and let the agent break it down even further. Always start with the tiniest one, and solve one problem at a time. Vertical slicing and TDD ZOMBIES have proven effective. âœ… Test First Pattern: Start with the end in mind. No production code without a failing test. This is now more obvious than ever. The agent needs all the feedback it can get. Make sure it doesnâ€™t break things, and keep the code running all the time. ğŸ¤” Hypothesize Pattern: Have the agent state what it expects to happen. The Agent is often wrong about a code change. When that happens, it will attempt to recover from the situation, taking several tries. These will inevitably contaminate the context. It may even lead to the agent giving up and making things worse by leaving unintended changes â€” often stating that it indeed solved the problem. I found it helpful to have the agent express its expectations about a code change first, before it runs the code. For example, before it runs a failing test, it can express what it expects to happen. This reinforces the actual intent in the context. â“ Ask, donâ€™t tell. Pattern: Keep the solution space open. Donâ€™t tell the agent what to do, unless youâ€™re confident in the path forward. Consider that you might be wrong, or missing information. By telling it what to do, youâ€™re narrowing the solution space and leading the agent down a failure path. Instead, leverage its knowledge. Ask the right question to withdraw the relevant information into the context. Then use it, or store it in a relevant memory. This not only leads to better results â€” it creates a learning opportunity. ğŸš§ Constraints Pattern: Keep it on a short leash. The best way to help the agent avoid mistakes is to constrain what it can do. Instead of changing code freely, we can give it access to refactoring tools. We can lock it out of certain files or commands. Constraints are more than just rules â€” they shape what the agent can do or not do in its environment, enabling better and more reliable outputs. ğŸ›¡ï¸ Refactor Guard Pattern: Increase confidence in legacy code refactoring with micro ai code reviews. When working in legacy code, make the smallest possible refactoring step, then let the Agent review and make sure that behavior hasnâ€™t changed. If the checks pass, it may even commit automatically. If it finds an issue it warns you. ğŸ«· Stop Pattern: Keep your finger on the stop button. When the agent goes off the rails, for example when it does something it should not do, I like to stop it as quickly as I can. The earlier I do that, the better. I avoid contamination of the context and am more likely to help it recover without messing up the process. I like to use Ask, donâ€™t tell when giving it recovery instructions. âš™ï¸ Algorithmify Pattern: Automate whatever can be automated. Favor algorithms over stochastic outputs to avoid mistakes and have the agent write its own automation. Itâ€™s really good at this. What is automated: is deterministic. preserves cognitive capacity for other things. is often faster. Therefore, we want to automate as much as possible. ğŸ’ Stdout Distillation Pattern: Reduce verbose output to essential signals. The Stdout Distillation Pattern reduces verbose script output to only the essential information needed by an agent. Instead of flooding the context with logs, traces, or irrelevant details, the output is distilled into a concise signalâ€”such as a single line indicating success or failure. This minimizes context contamination, improves efficiency, and ensures the agent focuses only on what matters. Example: A test.sh script The script makes sure the test results are just a single line. Only if the tests fail, more output is shown. #!/usr/bin/env bash set -euo pipefail cd "$(dirname "$0")" if ! output=$(python -m pytest tests/ -v 2&gt;&amp;1); then echo "$output" exit 1 fi passed_tests=$(echo "$output" | grep -c "PASSED" || echo "0") echo "âœ… All $passed_tests tests passed" ğŸ–¥ï¸ CLI First Pattern: Let the agent thrive on the CLI. Agent tooling should be CLI-first. The LLMâ€™s native medium is chat â€” text in, text out. This is exactly what the CLI was made for. On top of that, it offers many small, composable Unix-style tools. Agents thrive on the command line â€” give them tools there. Conclusion I see a lot of â€œagileâ€ in the things that work well for me. Things like inspect and adapt, continuous improvement, small steps, iterate, TDD. The LLM is trained on and born into a waterfall world. When I look at the tooling people develop around it, and the things people do with it, I often see waterfall, too. And I see a lot of legacy code that will emerge. Maybe we can do better. Influences &amp; Inspirations It was LLewellyn Falco who first showed me the starter symbol as well as the output distillation pattern. The idea of Augmented Coding was at first sparked by Kent Beck. I discovered subtasking through the usage of Roo Code which already had this feature.]]></summary></entry><entry><title type="html">Takeaways from GeeCon Prague 2023</title><link href="http://gregorriegler.com/2023/10/21/geecon-prague-summary.html" rel="alternate" type="text/html" title="Takeaways from GeeCon Prague 2023" /><published>2023-10-21T00:00:00+00:00</published><updated>2023-10-21T00:00:00+00:00</updated><id>http://gregorriegler.com/2023/10/21/geecon-prague-summary</id><content type="html" xml:base="http://gregorriegler.com/2023/10/21/geecon-prague-summary.html"><![CDATA[<p>I recently attended GeeCon Prague, an event I had never been to before. While it wasnâ€™t as grand as the big Krakow event, I still found it a worthwhile decision to attend. Here are some highlights and things that resonated with me:</p>

<h2 id="what-i-discovered-and-deepened-my-understanding-on">What I Discovered and Deepened My Understanding On</h2>
<ul>
  <li>
    <p><strong>Availability Bias</strong>: While Iâ€™ve always felt its presence, I now have a formal term and understanding of it.</p>
  </li>
  <li>The <strong>Big Rewrite Song</strong> by Dylan Beattie is a beautiful one:
    <div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/xCGu5Z_vaps" frameborder="0" allowfullscreen=""></iframe></div>
    <p><br /></p>
  </li>
  <li>
    <p>There is evidence supporting my frequent claim that developers spend more time reading code than writing it. This is further discussed in the book â€˜The Programmerâ€™s Brainâ€™.</p>

    <p><img src="/assets/geecon-2023/more-time-reading-code.png" alt="We spend more time reading code" /></p>
  </li>
  <li>Thereâ€™s an insightful talk on <em>How to Teach</em> that isnâ€™t exclusive to programmers. I found it enlightening and recommend it:
    <div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/g1ib43q3uXQ" frameborder="0" allowfullscreen=""></iframe></div>
    <p><br /></p>
  </li>
  <li>
    <p>Interesting fact: Only 37% of code written five years ago is still in use today.</p>

    <p><img src="/assets/geecon-2023/focus-on-new-code.jpg" alt="Focus On New Code" /></p>
  </li>
  <li>
    <p>The â€œ<strong>First Glance</strong>â€ technique for reading code is intriguing. It involves group members sharing what stood out to them in the initial minute of reading a piece of code. I now want to try this in an ensemble setting.</p>
  </li>
  <li>
    <p>You donâ€™t really need anything other than Redis ğŸ¤£.</p>
  </li>
  <li>
    <p>There is more to Pattern Matching than I had anticipated.</p>
  </li>
  <li>
    <p>Javaâ€™s efficiency has notably improved.</p>

    <p><img src="/assets/geecon-2023/java-efficiency.png" alt="Java Efficiency Chart" /></p>
  </li>
  <li>
    <p><strong>On Crafting Better IDs</strong>:
  While UUIDs are reliable, theyâ€™re not the fastest. Creating a custom solution could be more efficient. UUIDs rely on secrandom, which is often unnecessary and slows down the process.</p>

    <p>XUID variations exist that maintain order. If youâ€™re keen on using UTC, consider synchronizing time across services with NTP. A suggestion for EventIds: prefix them with the domain they originate from. To avoid potential issues, implement a processing count to ward off circular flows and employ tracingIds to streamline debugging in microservices.</p>
  </li>
</ul>

<h2 id="moments-of-inspiration-and-reflection">Moments of Inspiration and Reflection</h2>
<ul>
  <li>
    <p>It felt good seeing Michael Featherâ€™s Talk, as it provided me with a different perspective on trying to TDD with ChatGPT. Also, it was nice to exchange Ideas on the topic.</p>

    <p><img src="/assets/geecon-2023/tdd-with-gpt.png" alt="TDD with GPT" /></p>
  </li>
  <li>
    <p>Tannaz N. Roshandel highlighted the ethical challenges we face in a rapidly changing world in the digital age. I wholeheartedly agree. As we employ AI for sophisticated classification and recommendation, we amplify division. Can we harness AI to counteract this?</p>
  </li>
  <li>
    <p>Overall, the technological landscape is constantly evolving and increasing in its complexity, overshadowing what is essential. To break the <strong>cycle of creating messes</strong>, we must shift our <strong>focus on the fundamentals</strong>. However, Iâ€™ve come to see that serverless might be a promising solution.</p>
  </li>
  <li>
    <p>Meeting <a href="https://talkweb.eu/">Bogo</a> and heading to a pub with him to enjoy some excellent Czech beer was definitely a highlight! 
Thanks Bogo! ğŸ»</p>
  </li>
</ul>

<h3 id="more-photos">More Photos</h3>
<p>Bogos Talk.
<img src="/assets/geecon-2023/no-time-for-fun.png" alt="No Time For Fun" /></p>

<p>He smashed his Phone ğŸ¤¯
<img src="/assets/geecon-2023/bogo-smash-phone.png" alt="Bogo smashing his Phone" /></p>

<p>Michael Feathers proposed an idea on how to understand code using ChatGPT.
<img src="/assets/geecon-2023/gpt-responsibilities-of-code.png" alt="An Idea how to use ChatGPT to read code" /></p>

<p>I had a nice view from the balcony of my hotel.
<img src="/assets/geecon-2023/view-from-hotel.png" alt="View from hotel" /></p>

<p>Prague at Night.
<img src="/assets/geecon-2023/prague-at-night.png" alt="Prague at Night" /></p>

<p>Prague at Day.
<img src="/assets/geecon-2023/prague-at-day.png" alt="Prague at Day" /></p>]]></content><author><name>Gregor Riegler</name></author><category term="GeeCon" /><summary type="html"><![CDATA[I recently attended GeeCon Prague, an event I had never been to before. While it wasnâ€™t as grand as the big Krakow event, I still found it a worthwhile decision to attend. Here are some highlights and things that resonated with me: What I Discovered and Deepened My Understanding On Availability Bias: While Iâ€™ve always felt its presence, I now have a formal term and understanding of it. The Big Rewrite Song by Dylan Beattie is a beautiful one: There is evidence supporting my frequent claim that developers spend more time reading code than writing it. This is further discussed in the book â€˜The Programmerâ€™s Brainâ€™. Thereâ€™s an insightful talk on How to Teach that isnâ€™t exclusive to programmers. I found it enlightening and recommend it: Interesting fact: Only 37% of code written five years ago is still in use today. The â€œFirst Glanceâ€ technique for reading code is intriguing. It involves group members sharing what stood out to them in the initial minute of reading a piece of code. I now want to try this in an ensemble setting. You donâ€™t really need anything other than Redis ğŸ¤£. There is more to Pattern Matching than I had anticipated. Javaâ€™s efficiency has notably improved. On Crafting Better IDs: While UUIDs are reliable, theyâ€™re not the fastest. Creating a custom solution could be more efficient. UUIDs rely on secrandom, which is often unnecessary and slows down the process. XUID variations exist that maintain order. If youâ€™re keen on using UTC, consider synchronizing time across services with NTP. A suggestion for EventIds: prefix them with the domain they originate from. To avoid potential issues, implement a processing count to ward off circular flows and employ tracingIds to streamline debugging in microservices. Moments of Inspiration and Reflection It felt good seeing Michael Featherâ€™s Talk, as it provided me with a different perspective on trying to TDD with ChatGPT. Also, it was nice to exchange Ideas on the topic. Tannaz N. Roshandel highlighted the ethical challenges we face in a rapidly changing world in the digital age. I wholeheartedly agree. As we employ AI for sophisticated classification and recommendation, we amplify division. Can we harness AI to counteract this? Overall, the technological landscape is constantly evolving and increasing in its complexity, overshadowing what is essential. To break the cycle of creating messes, we must shift our focus on the fundamentals. However, Iâ€™ve come to see that serverless might be a promising solution. Meeting Bogo and heading to a pub with him to enjoy some excellent Czech beer was definitely a highlight! Thanks Bogo! ğŸ» More Photos Bogos Talk. He smashed his Phone ğŸ¤¯ Michael Feathers proposed an idea on how to understand code using ChatGPT. I had a nice view from the balcony of my hotel. Prague at Night. Prague at Day.]]></summary></entry><entry><title type="html">Solo Programming Considered Harmful</title><link href="http://gregorriegler.com/2023/01/30/solo-programming-considered-bad.html" rel="alternate" type="text/html" title="Solo Programming Considered Harmful" /><published>2023-01-30T00:00:00+00:00</published><updated>2023-01-30T00:00:00+00:00</updated><id>http://gregorriegler.com/2023/01/30/solo-programming-considered-bad</id><content type="html" xml:base="http://gregorriegler.com/2023/01/30/solo-programming-considered-bad.html"><![CDATA[<p>I was recently following an interesting discussion of the Vienna software crafts community with the title: â€œ<a href="https://github.com/swkWien/sessions/issues/105">How to facilitate a conversation between people, where the byproduct is code?</a>â€. The discussion is in German and contains interesting ideas about how to code well together, and how to facilitate it.
I tried to give an answer, which got longer and longer.
In the end, I chose to write this blog post which expands upon the original topic of discussion and covers a broader range of related subjects.</p>

<p>I will continue to use the terms</p>

<ul>
  <li>coding together</li>
  <li>collaborative coding</li>
  <li>Mob Programming, and</li>
  <li>Ensemble Programming</li>
</ul>

<p>interchangeably.
However, when I say <em>coding together</em> or <em>collaborative coding</em> this includes Pair Programming.
When I say <em>Mob Programming</em> or <em>Ensemble Programming</em> I exclude Pair Programming.
By the way: Yes, Mob Programming and Ensemble Programming mean the same thing and may be used interchangeably.
Itâ€™s just that the word â€œMobâ€ might be associated with something negative, whereas â€œEnsembleâ€ is a more innocent term.
However, I like to use â€œMobâ€ as a verb because itâ€™s so short and simple:</p>

<ul>
  <li>â€œLetâ€™s mob on this problem!â€</li>
  <li>â€œWe have been mobbing on this problem.â€</li>
</ul>

<h2 id="solo-programming-considered-harmful">Solo Programming Considered Harmful</h2>

<p><img src="/assets/mob-programming/solo-programming.png" alt="Solo Programming" title="A Solo Programmer" />
<em>Â» A programmer is a person sitting solo in front of their computer, typing rapidly on their keyboard.
A well known stereotype. You have seen the movies.</em></p>

<p>It turns out that solo programming may not be as good as we think.
No, Iâ€™m serious.
I think we overestimate our programming skills.
We tend to overcomplicate things, and we make a lot of mistakes.
We rarely understand the problem that needs to be solved, and we donâ€™t know our tools well.
We often end up with crufty code that isnâ€™t as simple as it could be.
It doesnâ€™t work and often targets the wrong problem.</p>

<p>But hey, donâ€™t worry about it.
We donâ€™t mean to.
We try hard to live up to expectations.
And we work to the best of our ability.
Weâ€™re learning.
Itâ€™s just not that easy. ğŸ¤·â€â™‚ï¸</p>

<h2 id="coding-together-as-an-answer">Coding Together as an Answer</h2>
<p>Collaborative coding can greatly improve the situation.
By bringing together multiple people with different skills and perspectives, we can gain a deeper understanding of the problem and develop a better solution.
We can take on different roles and complement each other.
We have more eyes to spot mistakes, and together we know our tools better and know more about valuable techniques and practices.
Itâ€™s proven that complex problems can be solved better and faster through collaborative coding.
Working on simple applications, we encounter such hard-to-solve problems every day.
But the best thing about coding together is the amplified learning while having a good time.</p>

<p><img src="/assets/mob-programming/remote-mob-programming.png" alt="Remote Mob Programming" title="Image Caption" />
<em>Â» A team coding together remotely.</em></p>

<h2 id="the-cost-of-coding-together">The Cost of Coding Together</h2>
<p>There is a cost, of course, to having many programmers working on the same problem at the same time.
We understand those costs well, I think.
What we do not understand so well, however, are the benefits.
Ultimately, itâ€™s a tradeoff.
Will the benefits outweigh the costs?
So let us talk about the benefits.</p>

<h2 id="the-benefits-of-coding-together">The Benefits of Coding Together</h2>

<h3 id="amplified-learning">Amplified Learning</h3>
<p>The most striking advantage, and I cannot emphasise this enough, is the amplification in learning.
We need to learn and get better at what we do, desperately so.
All of us, but especially those of us who are new to it.
Thereâ€™s a big gap between what you learn in school and what you need to know on the job.
We have to make up for that gap somehow.
The thing that works best in my experience is to work together with the people.
Coding together isnâ€™t only the best way to onboard new people, but it also succeeds amazingly quickly in raising the level of participants and turning them into valuable contributors.
Iâ€™ve learned so much myself through programming with other people that I honestly believe the learning effect alone makes up for the cost.</p>

<h3 id="reduction-in-cost-for-change">Reduction in Cost for Change</h3>
<p>We are used to a trade-off between quality and cost, but it does not work that way with software.
In our business, quality is cheap and cruft is expensive.</p>

<blockquote>
  <p>ğŸ’¡ Martin Fowler wrote an interesting <a href="https://martinfowler.com/articles/is-quality-worth-cost.html">article</a> on this topic.</p>
</blockquote>

<p>Code is a liability, and much of the cost is incurred when we need to change and improve it, which happens from day one.
There is this strange idea that maintenance is something that happens after the project is completed.
Well, thatâ€™s not exactly true.
We maintain the code starting with the first day.
Itâ€™s a challenge to find the right structure and keep it soft enough to change easily.
Itâ€™s also terribly expensive to work on poorly designed legacy code, as we often see in enterprise software today.
The cost of this is insidious because there is usually no awareness of it.
So we should strive for and achieve high <a href="https://wiki.c2.com/?InternalAndExternalQuality">internal quality</a> to save maintenance cost.
The internal quality of the code can be greatly increased if many people review and revise the code as itâ€™s written.</p>

<h3 id="better-software-for-the-user">Better Software for the User</h3>
<p>I have seen this repeatedly: Many minds working on the same problem produce more and better ideas, which simply leads to better solutions.
When I say better, I usually mean simpler.
Itâ€™s those moments when the majority chase a suboptimal solution and then one person proposes a better one.
We need to think outside the box.
Different people think in different boxes.
More boxes mean more opportunities.
More opportunities lead to a better outcome for the user.</p>

<h3 id="reduced-work-in-progress">Reduced Work in Progress</h3>
<p>We know that high work in progress causes slow down.
When we work together on one problem, itâ€™s also the only problem we work on.
All the people needed to solve the problem are there when theyâ€™re needed.
And then, once weâ€™ve taken all the necessary action, itâ€™s done.
Itâ€™s off the table.
We can focus entirely on the next problem.
No juggling of tasks.
No waiting around.
No context switching.
Fewer things to keep everyone busy.
Better and easier focus.
A clean one-piece flow.</p>

<h3 id="having-a-good-time">Having a Good Time</h3>
<p>For many people, it can be rewarding to work in a mob with other people, especially if theyâ€™re more experienced.
When working on software, weâ€™re often thrown in at the deep end.
Teamwork reduces the stress involved in this.
Itâ€™s also more enjoyable for many.
Coding together is a great team-building activity because we work as an actual team.
It may feel awkward at first, but once you get the hang of it, it can be a lot of fun.</p>

<h2 id="mob-programming-is-not-easy">Mob Programming is Not Easy</h2>
<p>Coding together is challenging.
Itâ€™s not simply a matter of one person typing while others observe in silence.
In order to make it work, itâ€™s important for all team members to actively engage and collaborate. 
This enables us to utilize all of our minds and build the shared understanding we strive for.
Also, we want to reach a flow state and make continuous progress.
Mob Programming, thus working as an actual team, is a deliberate practice.</p>

<h3 id="shared-understanding">Shared Understanding</h3>
<p>Itâ€™s important to ensure that everyone is on the same page and no one is left behind.
This requires patience, effective communication, and a willingness to listen and explain ideas.
Communication is a challenge, but a skill we can improve with practice.
Speak slowly and use simple language.
Use metaphors and pick people up where they are.
When starting out with a new ensemble, itâ€™s common to feel slow at first. 
This is normal as the ensemble gets to know each other and establishes a shared understanding. 
After some time you should experience a boost in productivity. 
The duration of this initial phase can vary, it could be as short as a few minutes or as long as an hour.</p>

<h3 id="so-its-all-about-human-interaction">So, itâ€™s all About Human Interaction</h3>
<p>Treat each other with kindness, consideration and respect<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
Make people feel safe to contribute, and welcome all forms of contribution, including questions.
Reward a contribution, especially if it makes the person feel unsure.
It is perfectly fine not to know something or not to â€œget itâ€.
Be a hero and ask the first question to make others feel confident as well.
Be open to examining and evaluating potentially disruptive ideas, even if they come up suddenly.
Creating a supportive environment that encourages people to contribute will help ensure that the best ideas and insights from all team members are incorporated into the code.
It seems like social skills are the name of the game.
Has programming been the easy part all along?</p>

<h3 id="agree-on-a-shared-goal">Agree on a Shared Goal</h3>
<p>With many different ideas being shared, it can be difficult for a team to agree on a common goal.
This is another team skill to master.
Itâ€™s important to be open to taking a step back and trying someone elseâ€™s idea.
Itâ€™s okay to try multiple approaches and see which one works best.
By being open to different ideas and perspectives, a team can learn and grow together.</p>

<h3 id="knowing-when-to-speak">Knowing when to Speak</h3>
<p>Itâ€™s important for everyone to feel comfortable speaking their mind and sharing their ideas.
However, itâ€™s also important to know when to hold back and listen to others.
One way to deal with this is to keep a private backlog of ideas that come to mind but may not be relevant at the moment.
This can help keep you focused on the task at hand while recording and considering other ideas for later.
Knowing when to speak up and when to hold back is an important skill for effective collaboration.</p>

<h3 id="bias-to-action">Bias to Action</h3>
<p>In a group, itâ€™s sometimes easy to get stuck in a discussion that goes on forever without trying anything.
Most of the time, itâ€™s less stressful to just try.
Some discussions just are not worth it.
If you notice people talking for several minutes without writing any code, alarm bells should be ringing.
For example, if people are puzzling over the behavior of a particular code for an extended period of time.
Itâ€™s time to call to action and suggest that you simply run the code and see.</p>

<h2 id="distributing-roles">Distributing Roles</h2>
<p>A logical first step is to distribute participants by what they do.
Someone has to type the code, of course.
A common name for this role is <em>Driver</em>, as in the <em>Driver/Navigator</em> relationship of <a href="http://llewellynfalco.blogspot.com/2014/06/llewellyns-strong-style-pairing.html">Strong Style Pairing</a>.
I often find that people confuse the names of these two roles, so I prefer to call them â€œTypistâ€ and â€œTalkerâ€ instead.
May also use â€œTypingâ€ and â€œTalkingâ€.</p>

<h3 id="the-role-of-the-typist">The Role of the Typist</h3>
<p>We do not want the Typist to just hack away.
If they did, other participants could merely descipher the then buggy code and make incorrect assumptions.
Thatâ€™s not sustainable.
We want the Typist to follow the teamâ€™s instructions instead.
Being a Typist is hard.
They may get overwhelmed with conflicting ideas.
What should they focus on?
We can solve this problem by using a designated Talker.
Itâ€™s not the only person who speaks, but they act as the primary input channel for the Typist, filtering all the ideas and making the final decision.
Even if many things are said, the Typist then knows which voice to focus on.</p>

<h4 id="a-typist-translates">A Typist Translates</h4>
<p>It is a common misconception that the Typist foolishly types out the code theyâ€™ve been told to type, word by word, character by character.
Actually, the Typist must make many considerations and decisions.
For example: They may choose to run the tests whenever.
They translate the Talkerâ€™s intention into code so that the Talker can stay at the level of their thinking.
The Typist takes care of the details.
That takes a big burden off the Talker.
I mean, typing in itself is quite a challenge.
To know your tools well and being good at typing is an art.
If you are then able to translate the high level intent on top of that, thatâ€™s icing on the cake.</p>

<h4 id="typist-wrapups">Typist Wrapups</h4>
<p>One technique I learned at the Python Approvals Mob that improves feedback and shared understanding is Typist wrapups.
It means that a Typist gives a brief explanation of what just happened and what they did after each round.
When a Typist explains this in their own words, misunderstandings are more likely to be uncovered and cleared up.</p>

<h3 id="being-a-talker-is-not-easy-either">Being a Talker is not Easy Either</h3>
<p>So the Talker is the person who programmes.
The Typist acts as a kind of intelligent input device for them.
A Talker should communicate their thinking.
In other words, they should think out loud.
There are many stages of thinking that we go through.
First, we orient ourselves to the current situation - the context.
Second, we imagine where we want to go from here - a direction.
Third, we formulate a concrete intention - still at a high level.
This is already what a Typist could work with.
Each thought step is shared with the team.
Only then, if needed, do we move on to low-level details: What code to write on what line, syntax, code formatting, keys to use, buttons to click, etc.
The Talker instructs the Typist at the level at which they can operate on, the higher, the better.
Kind of like inverted limbo: How high can you get?</p>

<h3 id="contributing-while-not-talking-nor-typing">Contributing while not Talking nor Typing</h3>
<p>Not being any of those roles doesnâ€™t mean youâ€™re not contributing.
You may step out of the mob for a minute, but what you rather want is to be creative in supporting the group.
Do some research when an opportunity arises.
Ask, if you donâ€™t understand something.
Remind people about the protocol if necessary.
Think ahead and take notes about things we should take care of.
Review the code as it is being typed.
Observe how the group behaves and what they are doing.
Maybe you have an Idea of something the group should be trying that could work well, bring that up. 
Note down things that worked well so you can bring it up in the retro.</p>

<h2 id="rotation">Rotation</h2>
<p>Everyone should get to type and talk.
This keeps everybody engaged.
When deciding on the rotation interval, consider how long it would take for the same person to become a Typist again.
Waiting an hour to go back to typing is probably too much.
Itâ€™s hard to maintain attention that long.
A rotation every 2 or 3 minutes works very well with an experienced mob, but you need to be able to do it swiftly.
Work hard to shorten your rotation time.
Rotation time is the time between the start of a rotation and the next Typist/Talker being able to continue.
The perfect rotation time is 0.</p>

<h3 id="rotations-need-trust">Rotations Need Trust</h3>
<p>Ending your turn thus giving up control can be difficult.
As a Talker, you not only want to maintain the direction of the previous Talker, but you must trust the next Talker to do the same.
Trust them to continue the idea you have been working on.
Without trust, rotations get bogged down, which hinders the flow.</p>

<h3 id="hard-rotations-vs-finish-your-thought">Hard Rotations vs â€œFinish Your Thoughtâ€</h3>
<p>When the timer sounds, you have the option to do a hard rotation, where work stops immediately and team members rotate positions.
Another option is to take some time and finish your current thought, known as â€œFinish Your Thoughtâ€ (FYT). 
FYT is useful for completing something small or finishing a line of code. 
However, when it takes too long, it can disrupt the flow of the team. 
People might forget or even ignore that the timer rang at all.
Based on my experience, in those cases, itâ€™s better to do a hard rotation. 
Trust in the next person to pick up where you left off and continue the teamâ€™s intent.</p>

<h3 id="calling-out-your-role">Calling out your Role</h3>
<p>Another common practice that helps maintain flow is when everybody calls out their role when the rotation starts.
Itâ€™s practical to also have the person that will be participating in the following rotation to call that out as being â€œnextâ€.
This avoids misunderstandings and it makes sure that the â€œnextâ€ person is increasing their attention towards being able and continue the given work.</p>

<p>An example would be:<br />
Alice: â€œIâ€™m Alice, and Iâ€™m talking!â€<br />
Peter: â€œIâ€™m Peter, and Iâ€™m typing!â€<br />
Sarah: â€œIâ€™m Sarah, and Iâ€™m next!â€<br /></p>

<h2 id="find-out-what-works-for-your-mob">Find out what Works for Your Mob</h2>
<p>As mentioned earlier, Mob Programming is a deliberate practice.
You want to constantly improve the way you work together.
There are no pre-existing rules or frameworks for this.
You need to find your own working agreements.
Regular retrospectives are key in this regard.
Conduct them at least daily.
A two-hour Mob Programming session can lead to a three-hour retrospective, which is great.
The learning effect can be tremendous.
But they donâ€™t have to be that long.
Make them short, maybe a few minutes, but regular.
Use them to find out what worked well for you, and put that in the spotlight.
Turn up the good.
Stay innovative and figure out what youâ€™d like to try.
Retrospectives are about learning and about change.
Use it, act on its results.</p>

<h2 id="facilitating-a-mob-programming">Facilitating a Mob Programming</h2>
<p>Above all, remind the participants to be patient and treat each other with kindness, consideration, and respect<sup id="fnref:1:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
Be a role model in the way you treat them.
People new to Mob Programming will be overwhelmed just by the conviviality of this way of working.
Suddenly they have to pitch their ideas to other people.
They are also not used to being exposed while typing code.
It will take some time for them to get used to this way of working and still have some room in their head to keep a protocol intact.
So you want the initial protocol to be minimalist, and you want to guide it.
Too many rules would throw them off the rails.</p>

<blockquote>
  <p><strong>Tip:</strong> When you notice someone being distracted, offer a short break.</p>
</blockquote>

<h3 id="guide-your-protocol">Guide your Protocol</h3>
<p>There is a fine line between telling everyone what to do all the time and letting them off the hook.
In the beginning, they wonâ€™t remember how to follow your protocol.
Itâ€™s just too much.
So you should guide them and kindly tell them what to do and when.
But you also donâ€™t want to fall into the trap of doing everything for them.
Your goal is for the team to be able to take care of themselves and for you to become redundant.
Therefore, every time before you remind them, you should also give them some time to follow the protocol themselves.
Once you become redundant, you may consider joining the mob.</p>

<blockquote>
  <p><strong>Tip:</strong> Do not join a fresh ensemble as a facilitator unless you are very experienced in this. 
Facilitation can be complicated, therefor you do not want to particiate in the programming at first.
Stay out of the ensemble and focus on having them work well together.</p>
</blockquote>

<h3 id="keep-time-for-a-retrospective">Keep Time for a Retrospective</h3>
<p>You want to end a Mob Programming session with a retro.
Give them the chance to express their feelings about what happened, and share it with each other.
They probably enjoyed it.
Also, they have probably learned new things in the progress.</p>

<h4 id="microretro">Microretro</h4>
<p>A minimal but nice format for a retro is a microretro.
It only takes a few minutes and you could do it at least once a day.
In this retro, ask these questions:</p>

<ol>
  <li><strong>How did that feel?</strong></li>
  <li>
    <p><strong>What worked well?</strong></p>

    <p>The aim of this question is to highlight the positive aspects and achievements. 
We want to celebrate what went well and strive to replicate it in the future. 
Itâ€™s easy to get caught up in dwelling on negative aspects, but this can lead to a negative mindset and impact the overall well-being of the team. 
Therefore, this retro focuses on shifting the perspective entirely towards the positive.</p>
  </li>
  <li>
    <p><strong>Do you have an idea you would like to try?</strong></p>

    <p>The goal of this question is to foster experimentation and innovation.</p>
  </li>
</ol>

<h3 id="tools-for-mob-programming">Tools for Mob Programming</h3>

<ul>
  <li><a href="https://mob.sh">mob.sh</a> is a commandline tool and git wrapper to easily hand over code in a remote mob programming.</li>
  <li><a href="https://mobti.me/">mobti.me</a> is an online mob timer, and the best that I know.</li>
  <li><a href="https://gitpod.io/">gitpod</a> is a webapp that is basically vscode in the browser that works well for collaboration as you can share your workspace with others.</li>
  <li><a href="https://github.com/gregorriegler/remdev-azure">remdev on azure</a> is a script to easily boot up a virtual machine on azure for remote mob programming.</li>
  <li><a href="https://cyber-dojo.org/">cyber-dojo</a> is a brilliant webapp to practice mob programming on a kata. All you need is a browser.</li>
  <li><a href="https://tmate.io/">tmate</a> allows you to share your terminal with others to collaborate.</li>
</ul>

<h3 id="public-mobs">Public Mobs</h3>

<p>If you want to try Mob Programming you may choose an existing community.</p>

<ul>
  <li><a href="https://github.com/gregorriegler/mob-programming-rpg">MobRPG Mob</a> is a weekly public remote mob on thursdays where we develop a webapp for the mob programming rpg. Read the <a href="https://github.com/gregorriegler/mob-programming-rpg#contribute">Contribute</a> section to find out how to join (Itâ€™s dead simple as in â€œjust show upâ€).</li>
  <li><a href="https://www.eventbrite.com/o/code-craft-saturdays-and-sundays-15457506392">Code Crafts Saturdays and Sundays</a> is a monthly event where you can try and practice Mob Programming and TDD.</li>
  <li><a href="https://github.com/approvals/ApprovalTests.Python/blob/main/docs/Contribute.md">Python Approvals Mob</a> is a weekly remote mob that works on the python version of the approvals testing library.</li>
  <li><a href="https://mobusoperandi.com/">Mobus Operandi</a> has a calendar with a lot of public mobs that you can join.</li>
</ul>

<h3 id="further-links">Further Links</h3>

<ul>
  <li><a href="https://www.youtube.com/channel/UCgt1lVMrdwlZKBaerxxp2iQ">Mob Mentality Show</a></li>
  <li><a href="https://www.youtube.com/watch?v=ZnyBoz7wMD0&amp;list=PLzmKmecq34A9rH7MMUYzFjXdV0jdwQoGh&amp;index=7&amp;ab_channel=TsvetanTsvetanov">Mobbing Discussion</a> (I particularly like this episode because Tim explains very well and shares valuable insights)</li>
  <li><a href="https://trello.com/b/1lfMkCOh/software-profession-resources">Resource Collection on Mob Programming and Software Profession</a></li>
  <li><a href="https://jay.bazuzi.com/Mobbing-Pattern-Language/">Mobbing Pattern Language</a></li>
  <li><a href="https://www.industriallogic.com/blog/scatter-gather/">Scatter Gather (The hidden cost of Solo Programming)</a></li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://www.youtube.com/watch?v=oq42E51Ufnk">Kindness, Consideration and Respect</a> are what make a healthy Mob Programming.Â <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a>Â <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name>Gregor Riegler</name></author><category term="Mob Programming" /><category term="Ensemble Programming" /><summary type="html"><![CDATA[I was recently following an interesting discussion of the Vienna software crafts community with the title: â€œHow to facilitate a conversation between people, where the byproduct is code?â€. The discussion is in German and contains interesting ideas about how to code well together, and how to facilitate it. I tried to give an answer, which got longer and longer. In the end, I chose to write this blog post which expands upon the original topic of discussion and covers a broader range of related subjects. I will continue to use the terms coding together collaborative coding Mob Programming, and Ensemble Programming interchangeably. However, when I say coding together or collaborative coding this includes Pair Programming. When I say Mob Programming or Ensemble Programming I exclude Pair Programming. By the way: Yes, Mob Programming and Ensemble Programming mean the same thing and may be used interchangeably. Itâ€™s just that the word â€œMobâ€ might be associated with something negative, whereas â€œEnsembleâ€ is a more innocent term. However, I like to use â€œMobâ€ as a verb because itâ€™s so short and simple: â€œLetâ€™s mob on this problem!â€ â€œWe have been mobbing on this problem.â€ Solo Programming Considered Harmful Â» A programmer is a person sitting solo in front of their computer, typing rapidly on their keyboard. A well known stereotype. You have seen the movies. It turns out that solo programming may not be as good as we think. No, Iâ€™m serious. I think we overestimate our programming skills. We tend to overcomplicate things, and we make a lot of mistakes. We rarely understand the problem that needs to be solved, and we donâ€™t know our tools well. We often end up with crufty code that isnâ€™t as simple as it could be. It doesnâ€™t work and often targets the wrong problem. But hey, donâ€™t worry about it. We donâ€™t mean to. We try hard to live up to expectations. And we work to the best of our ability. Weâ€™re learning. Itâ€™s just not that easy. ğŸ¤·â€â™‚ï¸ Coding Together as an Answer Collaborative coding can greatly improve the situation. By bringing together multiple people with different skills and perspectives, we can gain a deeper understanding of the problem and develop a better solution. We can take on different roles and complement each other. We have more eyes to spot mistakes, and together we know our tools better and know more about valuable techniques and practices. Itâ€™s proven that complex problems can be solved better and faster through collaborative coding. Working on simple applications, we encounter such hard-to-solve problems every day. But the best thing about coding together is the amplified learning while having a good time. Â» A team coding together remotely. The Cost of Coding Together There is a cost, of course, to having many programmers working on the same problem at the same time. We understand those costs well, I think. What we do not understand so well, however, are the benefits. Ultimately, itâ€™s a tradeoff. Will the benefits outweigh the costs? So let us talk about the benefits. The Benefits of Coding Together Amplified Learning The most striking advantage, and I cannot emphasise this enough, is the amplification in learning. We need to learn and get better at what we do, desperately so. All of us, but especially those of us who are new to it. Thereâ€™s a big gap between what you learn in school and what you need to know on the job. We have to make up for that gap somehow. The thing that works best in my experience is to work together with the people. Coding together isnâ€™t only the best way to onboard new people, but it also succeeds amazingly quickly in raising the level of participants and turning them into valuable contributors. Iâ€™ve learned so much myself through programming with other people that I honestly believe the learning effect alone makes up for the cost. Reduction in Cost for Change We are used to a trade-off between quality and cost, but it does not work that way with software. In our business, quality is cheap and cruft is expensive. ğŸ’¡ Martin Fowler wrote an interesting article on this topic. Code is a liability, and much of the cost is incurred when we need to change and improve it, which happens from day one. There is this strange idea that maintenance is something that happens after the project is completed. Well, thatâ€™s not exactly true. We maintain the code starting with the first day. Itâ€™s a challenge to find the right structure and keep it soft enough to change easily. Itâ€™s also terribly expensive to work on poorly designed legacy code, as we often see in enterprise software today. The cost of this is insidious because there is usually no awareness of it. So we should strive for and achieve high internal quality to save maintenance cost. The internal quality of the code can be greatly increased if many people review and revise the code as itâ€™s written. Better Software for the User I have seen this repeatedly: Many minds working on the same problem produce more and better ideas, which simply leads to better solutions. When I say better, I usually mean simpler. Itâ€™s those moments when the majority chase a suboptimal solution and then one person proposes a better one. We need to think outside the box. Different people think in different boxes. More boxes mean more opportunities. More opportunities lead to a better outcome for the user. Reduced Work in Progress We know that high work in progress causes slow down. When we work together on one problem, itâ€™s also the only problem we work on. All the people needed to solve the problem are there when theyâ€™re needed. And then, once weâ€™ve taken all the necessary action, itâ€™s done. Itâ€™s off the table. We can focus entirely on the next problem. No juggling of tasks. No waiting around. No context switching. Fewer things to keep everyone busy. Better and easier focus. A clean one-piece flow. Having a Good Time For many people, it can be rewarding to work in a mob with other people, especially if theyâ€™re more experienced. When working on software, weâ€™re often thrown in at the deep end. Teamwork reduces the stress involved in this. Itâ€™s also more enjoyable for many. Coding together is a great team-building activity because we work as an actual team. It may feel awkward at first, but once you get the hang of it, it can be a lot of fun. Mob Programming is Not Easy Coding together is challenging. Itâ€™s not simply a matter of one person typing while others observe in silence. In order to make it work, itâ€™s important for all team members to actively engage and collaborate. This enables us to utilize all of our minds and build the shared understanding we strive for. Also, we want to reach a flow state and make continuous progress. Mob Programming, thus working as an actual team, is a deliberate practice. Shared Understanding Itâ€™s important to ensure that everyone is on the same page and no one is left behind. This requires patience, effective communication, and a willingness to listen and explain ideas. Communication is a challenge, but a skill we can improve with practice. Speak slowly and use simple language. Use metaphors and pick people up where they are. When starting out with a new ensemble, itâ€™s common to feel slow at first. This is normal as the ensemble gets to know each other and establishes a shared understanding. After some time you should experience a boost in productivity. The duration of this initial phase can vary, it could be as short as a few minutes or as long as an hour. So, itâ€™s all About Human Interaction Treat each other with kindness, consideration and respect1. Make people feel safe to contribute, and welcome all forms of contribution, including questions. Reward a contribution, especially if it makes the person feel unsure. It is perfectly fine not to know something or not to â€œget itâ€. Be a hero and ask the first question to make others feel confident as well. Be open to examining and evaluating potentially disruptive ideas, even if they come up suddenly. Creating a supportive environment that encourages people to contribute will help ensure that the best ideas and insights from all team members are incorporated into the code. It seems like social skills are the name of the game. Has programming been the easy part all along? Agree on a Shared Goal With many different ideas being shared, it can be difficult for a team to agree on a common goal. This is another team skill to master. Itâ€™s important to be open to taking a step back and trying someone elseâ€™s idea. Itâ€™s okay to try multiple approaches and see which one works best. By being open to different ideas and perspectives, a team can learn and grow together. Knowing when to Speak Itâ€™s important for everyone to feel comfortable speaking their mind and sharing their ideas. However, itâ€™s also important to know when to hold back and listen to others. One way to deal with this is to keep a private backlog of ideas that come to mind but may not be relevant at the moment. This can help keep you focused on the task at hand while recording and considering other ideas for later. Knowing when to speak up and when to hold back is an important skill for effective collaboration. Bias to Action In a group, itâ€™s sometimes easy to get stuck in a discussion that goes on forever without trying anything. Most of the time, itâ€™s less stressful to just try. Some discussions just are not worth it. If you notice people talking for several minutes without writing any code, alarm bells should be ringing. For example, if people are puzzling over the behavior of a particular code for an extended period of time. Itâ€™s time to call to action and suggest that you simply run the code and see. Distributing Roles A logical first step is to distribute participants by what they do. Someone has to type the code, of course. A common name for this role is Driver, as in the Driver/Navigator relationship of Strong Style Pairing. I often find that people confuse the names of these two roles, so I prefer to call them â€œTypistâ€ and â€œTalkerâ€ instead. May also use â€œTypingâ€ and â€œTalkingâ€. The Role of the Typist We do not want the Typist to just hack away. If they did, other participants could merely descipher the then buggy code and make incorrect assumptions. Thatâ€™s not sustainable. We want the Typist to follow the teamâ€™s instructions instead. Being a Typist is hard. They may get overwhelmed with conflicting ideas. What should they focus on? We can solve this problem by using a designated Talker. Itâ€™s not the only person who speaks, but they act as the primary input channel for the Typist, filtering all the ideas and making the final decision. Even if many things are said, the Typist then knows which voice to focus on. A Typist Translates It is a common misconception that the Typist foolishly types out the code theyâ€™ve been told to type, word by word, character by character. Actually, the Typist must make many considerations and decisions. For example: They may choose to run the tests whenever. They translate the Talkerâ€™s intention into code so that the Talker can stay at the level of their thinking. The Typist takes care of the details. That takes a big burden off the Talker. I mean, typing in itself is quite a challenge. To know your tools well and being good at typing is an art. If you are then able to translate the high level intent on top of that, thatâ€™s icing on the cake. Typist Wrapups One technique I learned at the Python Approvals Mob that improves feedback and shared understanding is Typist wrapups. It means that a Typist gives a brief explanation of what just happened and what they did after each round. When a Typist explains this in their own words, misunderstandings are more likely to be uncovered and cleared up. Being a Talker is not Easy Either So the Talker is the person who programmes. The Typist acts as a kind of intelligent input device for them. A Talker should communicate their thinking. In other words, they should think out loud. There are many stages of thinking that we go through. First, we orient ourselves to the current situation - the context. Second, we imagine where we want to go from here - a direction. Third, we formulate a concrete intention - still at a high level. This is already what a Typist could work with. Each thought step is shared with the team. Only then, if needed, do we move on to low-level details: What code to write on what line, syntax, code formatting, keys to use, buttons to click, etc. The Talker instructs the Typist at the level at which they can operate on, the higher, the better. Kind of like inverted limbo: How high can you get? Contributing while not Talking nor Typing Not being any of those roles doesnâ€™t mean youâ€™re not contributing. You may step out of the mob for a minute, but what you rather want is to be creative in supporting the group. Do some research when an opportunity arises. Ask, if you donâ€™t understand something. Remind people about the protocol if necessary. Think ahead and take notes about things we should take care of. Review the code as it is being typed. Observe how the group behaves and what they are doing. Maybe you have an Idea of something the group should be trying that could work well, bring that up. Note down things that worked well so you can bring it up in the retro. Rotation Everyone should get to type and talk. This keeps everybody engaged. When deciding on the rotation interval, consider how long it would take for the same person to become a Typist again. Waiting an hour to go back to typing is probably too much. Itâ€™s hard to maintain attention that long. A rotation every 2 or 3 minutes works very well with an experienced mob, but you need to be able to do it swiftly. Work hard to shorten your rotation time. Rotation time is the time between the start of a rotation and the next Typist/Talker being able to continue. The perfect rotation time is 0. Rotations Need Trust Ending your turn thus giving up control can be difficult. As a Talker, you not only want to maintain the direction of the previous Talker, but you must trust the next Talker to do the same. Trust them to continue the idea you have been working on. Without trust, rotations get bogged down, which hinders the flow. Hard Rotations vs â€œFinish Your Thoughtâ€ When the timer sounds, you have the option to do a hard rotation, where work stops immediately and team members rotate positions. Another option is to take some time and finish your current thought, known as â€œFinish Your Thoughtâ€ (FYT). FYT is useful for completing something small or finishing a line of code. However, when it takes too long, it can disrupt the flow of the team. People might forget or even ignore that the timer rang at all. Based on my experience, in those cases, itâ€™s better to do a hard rotation. Trust in the next person to pick up where you left off and continue the teamâ€™s intent. Calling out your Role Another common practice that helps maintain flow is when everybody calls out their role when the rotation starts. Itâ€™s practical to also have the person that will be participating in the following rotation to call that out as being â€œnextâ€. This avoids misunderstandings and it makes sure that the â€œnextâ€ person is increasing their attention towards being able and continue the given work. An example would be: Alice: â€œIâ€™m Alice, and Iâ€™m talking!â€ Peter: â€œIâ€™m Peter, and Iâ€™m typing!â€ Sarah: â€œIâ€™m Sarah, and Iâ€™m next!â€ Find out what Works for Your Mob As mentioned earlier, Mob Programming is a deliberate practice. You want to constantly improve the way you work together. There are no pre-existing rules or frameworks for this. You need to find your own working agreements. Regular retrospectives are key in this regard. Conduct them at least daily. A two-hour Mob Programming session can lead to a three-hour retrospective, which is great. The learning effect can be tremendous. But they donâ€™t have to be that long. Make them short, maybe a few minutes, but regular. Use them to find out what worked well for you, and put that in the spotlight. Turn up the good. Stay innovative and figure out what youâ€™d like to try. Retrospectives are about learning and about change. Use it, act on its results. Facilitating a Mob Programming Above all, remind the participants to be patient and treat each other with kindness, consideration, and respect1. Be a role model in the way you treat them. People new to Mob Programming will be overwhelmed just by the conviviality of this way of working. Suddenly they have to pitch their ideas to other people. They are also not used to being exposed while typing code. It will take some time for them to get used to this way of working and still have some room in their head to keep a protocol intact. So you want the initial protocol to be minimalist, and you want to guide it. Too many rules would throw them off the rails. Tip: When you notice someone being distracted, offer a short break. Guide your Protocol There is a fine line between telling everyone what to do all the time and letting them off the hook. In the beginning, they wonâ€™t remember how to follow your protocol. Itâ€™s just too much. So you should guide them and kindly tell them what to do and when. But you also donâ€™t want to fall into the trap of doing everything for them. Your goal is for the team to be able to take care of themselves and for you to become redundant. Therefore, every time before you remind them, you should also give them some time to follow the protocol themselves. Once you become redundant, you may consider joining the mob. Tip: Do not join a fresh ensemble as a facilitator unless you are very experienced in this. Facilitation can be complicated, therefor you do not want to particiate in the programming at first. Stay out of the ensemble and focus on having them work well together. Keep Time for a Retrospective You want to end a Mob Programming session with a retro. Give them the chance to express their feelings about what happened, and share it with each other. They probably enjoyed it. Also, they have probably learned new things in the progress. Microretro A minimal but nice format for a retro is a microretro. It only takes a few minutes and you could do it at least once a day. In this retro, ask these questions: How did that feel? What worked well? The aim of this question is to highlight the positive aspects and achievements. We want to celebrate what went well and strive to replicate it in the future. Itâ€™s easy to get caught up in dwelling on negative aspects, but this can lead to a negative mindset and impact the overall well-being of the team. Therefore, this retro focuses on shifting the perspective entirely towards the positive. Do you have an idea you would like to try? The goal of this question is to foster experimentation and innovation. Tools for Mob Programming mob.sh is a commandline tool and git wrapper to easily hand over code in a remote mob programming. mobti.me is an online mob timer, and the best that I know. gitpod is a webapp that is basically vscode in the browser that works well for collaboration as you can share your workspace with others. remdev on azure is a script to easily boot up a virtual machine on azure for remote mob programming. cyber-dojo is a brilliant webapp to practice mob programming on a kata. All you need is a browser. tmate allows you to share your terminal with others to collaborate. Public Mobs If you want to try Mob Programming you may choose an existing community. MobRPG Mob is a weekly public remote mob on thursdays where we develop a webapp for the mob programming rpg. Read the Contribute section to find out how to join (Itâ€™s dead simple as in â€œjust show upâ€). Code Crafts Saturdays and Sundays is a monthly event where you can try and practice Mob Programming and TDD. Python Approvals Mob is a weekly remote mob that works on the python version of the approvals testing library. Mobus Operandi has a calendar with a lot of public mobs that you can join. Further Links Mob Mentality Show Mobbing Discussion (I particularly like this episode because Tim explains very well and shares valuable insights) Resource Collection on Mob Programming and Software Profession Mobbing Pattern Language Scatter Gather (The hidden cost of Solo Programming) Kindness, Consideration and Respect are what make a healthy Mob Programming.Â &#8617;Â &#8617;2]]></summary></entry><entry><title type="html">Getting better at CI</title><link href="http://gregorriegler.com/2022/07/21/Getting-better-at-CI.html" rel="alternate" type="text/html" title="Getting better at CI" /><published>2022-07-21T00:00:00+00:00</published><updated>2022-07-21T00:00:00+00:00</updated><id>http://gregorriegler.com/2022/07/21/Getting-better-at-CI</id><content type="html" xml:base="http://gregorriegler.com/2022/07/21/Getting-better-at-CI.html"><![CDATA[<p>I recently felt the urge to experiment with my TDD workflow and improve it.
It had too many manual steps, like running the tests, starting a commit, writing a commit message, pulling changes, and pushing it. 
It felt boring and wasteful.
I want to automate this stuff and eliminate all the waste.</p>

<p>Weâ€™re not aiming high enough with the continuous part in CI/CD.<br />
<em>â€œIntegrate at least dailyâ€</em> â€¦ Come on!<br />
<em>â€œHourlyâ€</em> â€¦ We can do better than this.<br />
<em>â€œShort-lived Feature Branchesâ€</em> â€¦ You got to be kidding. Itâ€™s rather <em>â€œshort-lived liesâ€</em>.<br />
None of this is continuous.
We need to get better and decrease the risk even further.
I want to integrate <em>actually continuously</em>.</p>

<p>My inspiration comes mainly from the ideas of <a href="https://martinfowler.com/articles/continuousIntegration.html">continuous integration</a>, continuous testing, <a href="https://medium.com/@kentbeck_7670/test-commit-revert-870bbd756864">TCR</a>, and <a href="https://medium.com/@kentbeck_7670/limbo-on-the-cheap-e4cfae840330">limbo on the cheap</a>.</p>

<h2 id="actually-continuously">Actually continuously</h2>

<p>I came up with a way that drastically increased my commit frequency.
I managed to create <strong>63 commits</strong> in just <strong>25 minutes</strong> practicing this way, where I peaked at <strong>6 commits per minute</strong>. 
Yes, it was just a kata, but thatâ€™s not the important part.
On many occasions literally every keystroke went live, and it was all working - covered by tests.</p>

<p>What I did is based on the following requirements:</p>

<ul>
  <li><strong>No manual saving</strong>. The code saves itself automatically.</li>
  <li><strong>No manual test running</strong>. The tests run continuously. They restart automatically as soon as the code changes. And they are <em>fast</em>.</li>
  <li><strong>No manual commits</strong>. The code is committed automatically whenever the tests pass.</li>
  <li><strong>No manual pulling</strong>. Changes are pulled automatically before the tests run.</li>
  <li><strong>No manual pushing</strong>. Every commit is automatically pushed right away.</li>
</ul>

<p>Not that hard to achieve actually.
Just need proper tooling and a little bit of scripting.
The language Iâ€™m trying this with is Java.</p>

<h2 id="the-right-tools-for-the-job">The right tools for the job</h2>

<p>Since I use IntelliJ, which is a great, maybe the best IDE (*<em>cough</em>* it became a little buggy as of recent *<em>cough</em>*), it saves my code automatically. 
So that problem is already solved.
For the continuous running of the tests, I know a few options.<br />
IntelliJ offers a way to trigger the tests automatically, but itâ€™s rather slow.
Then there is this old-school plugin <a href="https://infinitest.github.io/">infinitest</a>, but I need something for the CLI so I am able to script it. 
And it should be really fast. <a href="https://en.wikipedia.org/wiki/Incremental_compiler">Incremental compilation</a> would be key.<br />
<a href="https://blog.gradle.org/introducing-continuous-build">Gradle</a> has it, and it is quite fast.
With Gradle, I could also make the test report pretty using this <a href="https://github.com/radarsh/gradle-test-logger-plugin">test-logger plugin</a>.</p>

<p><img src="/assets/not-continuous-enough/nice-test-report.png" alt="Nice test report with the gradle test logger" /></p>

<p>I like that!</p>

<p>Another option would be the <a href="https://quarkus.io/guides/continuous-testing">quarkus continuous test runner</a>, which is fairly new, and its test report is so ugly.
Also, I have no idea how to customize, or script it.
So I am going with Gradle for now.</p>

<p>On top of the incremental compilation, Gradle ships with a continuous test runner in:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> gradle <span class="nt">-t</span> <span class="nb">test</span>
</code></pre></div></div>
<p>But since I need more control I chose to use a little helper tool called <a href="https://github.com/watchexec/watchexec">watchexec</a> instead.
It watches for file changes and then executes a command.
Like this:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> watchexec <span class="nt">-e</span> java ./gradlew <span class="nb">test</span>
</code></pre></div></div>
<p>I made some tests and it is just as fast as the Gradle continuous test runner.
If youâ€™d like even more control and a more complicated script, you could also use <a href="https://linux.die.net/man/1/inotifywait">inotifywait</a>.
However, I like to keep it as simple as possible.</p>

<p>Next, I needed to commit as soon as the tests pass. 
A simple bash script would do, but I like to use a modern task runner for the job.
I settled with <a href="https://github.com/casey/just">just</a>. 
In case you did not know, it is a modern version of <a href="https://savannah.gnu.org/projects/make">Make</a>.
And it is written in rust for whoever that may concern.
The way this works is you <em>just</em> create a <code class="language-plaintext highlighter-rouge">justfile</code> and specify your tasks in it.
The commit command looks like this.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit:
    @git add <span class="nb">.</span> 
    -@git commit <span class="nt">-am</span> <span class="s2">"wip"</span>
</code></pre></div></div>

<p>Simple and concise. 
To execute it you run:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> just commit
</code></pre></div></div>
<p>And I do not even have to remember.
My shell courteously suggests to me the available commands.<br />
The <code class="language-plaintext highlighter-rouge">@</code> means that the command is not printed.<br />
By default <code class="language-plaintext highlighter-rouge">just</code> would abort on an error exit code, whereas the <code class="language-plaintext highlighter-rouge">-</code> tells it to ignore that and continue.
I need this for the case where the tests pass, but I have not changed anything.
For example when I add something and delete it right away.
Then there would be nothing to commit, and <code class="language-plaintext highlighter-rouge">git</code> would throw the error, having <code class="language-plaintext highlighter-rouge">just</code> abort the task.
I could also allow the empty commit using the <a href="https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---allow-empty">allow-empty</a> flag.
But why allow an empty commit for no reason!?
That would be inventory, wasteful.</p>

<p>So here are the first commands in a <code class="language-plaintext highlighter-rouge">justfile</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commit:
    @git add <span class="nb">.</span> 
    -@git commit <span class="nt">-am</span> <span class="s2">"wip"</span>
    
<span class="nb">test</span>:
    clear
    @./gradlew <span class="nb">test

</span>test-commit:
    just <span class="nb">test 
    </span>just commit

tdd-commit:
    watchexec <span class="nt">-e</span> java just test-commit
</code></pre></div></div>

<p>Nice! I like it.</p>

<h2 id="first-try">First Try</h2>
<p>Now we are able to give it a try.
Small steps.</p>

<ul>
  <li>Run <code class="language-plaintext highlighter-rouge">&gt; just tdd-commit</code> in a terminal that stays visible next to the IDE.</li>
  <li>Write a very simple failing test; <strong>Tests fail</strong>. -&gt; The test failure is shown in the terminal immediately.</li>
  <li>Make the <strong>test pass</strong>. -&gt; Nicely formatted test report is shown immediately. Changes commit automatically.</li>
  <li>Rename the test method; <strong>Tests pass</strong>. -&gt; Changes commit automatically.</li>
  <li>Add another test; <strong>Tests fail</strong>. -&gt; I am shown the failure report.</li>
  <li>In a first attempt to make it pass I notice I cannot make it as easily. I need a preparatory refactoring first.</li>
  <li>So I disable the failing test; <strong>Tests pass again</strong>. -&gt; Changes commit automatically.</li>
  <li>I do the preparatory refactoring; <strong>Tests pass</strong>. -&gt; Changes commit automatically.</li>
  <li>I enable the failing test again; <strong>Tests fail</strong>. -&gt; I am shown the failure report.</li>
  <li>Make it pass this time; <strong>Tests pass</strong>. -&gt; Changes commit automatically.</li>
</ul>

<p>Wow, this felt smooth.
During all of this, I had not manually done a single save, test run, or commit.
The terminal was open on the right-hand side of my screen, and I got that feedback immediately, continuously.</p>

<h2 id="a-meaningless-commit-history">A meaningless commit history</h2>
<p>Letâ€™s take a look at the resulting git history.</p>

<ul>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
</ul>

<p>Whoops, thatâ€™s not very expressive.
But the commits are so small and pleasant to review.
Itâ€™s like a playback of every little step that was taken.
It is the actual history.
Honestly, I think the flow might have more value than the documentation.
Still, I would like to improve on that by sneaking in descriptive empty commits every once in a while.</p>

<p>We are used to writing git messages that describe what we did after we did it.
But for this, I would like to propose a different way.
I want to use a commit message to describe what is next. In other words: What my current goal is.
So letâ€™s add a command to create such descriptive empty commits.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goal +MESSAGE:
    git commit <span class="nt">--allow-empty</span> <span class="nt">-m</span> <span class="s2">"Goal: {{MESSAGE}}"</span>
</code></pre></div></div>

<p>Every time I start working on a new goal, I want to write it to my git history first.
Something like <code class="language-plaintext highlighter-rouge">&gt; just goal make rover turn left</code>.
The other commit messages would stay â€˜wipâ€™ commits and thatâ€™s fine.
One idea would be to use further tooling to decode some of the refactoring commits.
For example: The <a href="https://plugins.jetbrains.com/plugin/14704-refactorinsight">refactoringinsight</a> plugin.</p>

<p>My commit history would then look something like this:</p>

<ul>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
  <li>Goal: make rover turn left</li>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
  <li>wip</li>
  <li>Goal: make rover turn right</li>
</ul>

<h2 id="but-what-about-integration">But what about Integration?</h2>
<p>Lots of small commits on my computer are nice.
But if I work in a team I need to integrate my changes to the mainline, too.
So I want to pull before I run my tests, and I want to push after each commit.
Itâ€™s called Continuous Integration for a reason, right?</p>

<p>Letâ€™s add that to the justfile.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>integrate:     
    git pull <span class="nt">--rebase</span>
    just <span class="nb">test    
    </span>just commit  
    git push
</code></pre></div></div>
<p>And I think weâ€™re done.</p>

<p>This is the complete <a href="https://gist.github.com/gregorriegler/eafaa74250ff166925296dd58d4e62be">file</a>. 
It also contains a TCR task.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goal +MESSAGE:
    git pull <span class="nt">--rebase</span>
    git commit <span class="nt">--allow-empty</span> <span class="nt">-m</span> <span class="s2">"Goal: {{MESSAGE}}"</span>
    git push

commit:
    @git add <span class="nb">.</span> 
    -@git commit <span class="nt">-am</span> <span class="s2">"wip"</span>

<span class="nb">test</span>:
    clear
    @./gradlew <span class="nb">test
    
</span>integrate:
    git pull <span class="nt">--rebase</span>
    just <span class="nb">test 
    </span>just commit
    git push
    
tdd:
    watchexec <span class="nt">-e</span> java just <span class="nb">test

</span>ci:
    watchexec <span class="nt">-e</span> java just integrate

revert:
    @git reset <span class="nt">--hard</span> &amp;&gt; /dev/null
    @git clean <span class="nt">-df</span> &amp;&gt; /dev/null
    @echo <span class="nt">-e</span> <span class="s2">"</span><span class="se">\0</span><span class="s2">33[0;31m=== REVERTED ==="</span>
    
tcr:
    @just <span class="nb">test</span> <span class="o">&amp;&amp;</span> just commit <span class="o">||</span> just revert
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>Notice how I renamed the <code class="language-plaintext highlighter-rouge">tdd-commit</code> task to <code class="language-plaintext highlighter-rouge">ci</code>.
Continuous Integration is not only about what the build server is doing, it is primarily about what we do.</p>

<p>Coding with this script feels super smooth. 
It is actually continuous.</p>

<p>Also, it was not that complicated to set up.
You can probably do even better.</p>

<p>Imagine remote pair- or mob programming with this.
Hand-overs could not be easier. 
You just exchange the screen-sharing while the tests pass.
And thatâ€™s it.</p>

<p>Probably some people are already working this way? Let me know!</p>]]></content><author><name>Gregor Riegler</name></author><category term="TDD" /><category term="Continuous Integration" /><summary type="html"><![CDATA[I recently felt the urge to experiment with my TDD workflow and improve it. It had too many manual steps, like running the tests, starting a commit, writing a commit message, pulling changes, and pushing it. It felt boring and wasteful. I want to automate this stuff and eliminate all the waste. Weâ€™re not aiming high enough with the continuous part in CI/CD. â€œIntegrate at least dailyâ€ â€¦ Come on! â€œHourlyâ€ â€¦ We can do better than this. â€œShort-lived Feature Branchesâ€ â€¦ You got to be kidding. Itâ€™s rather â€œshort-lived liesâ€. None of this is continuous. We need to get better and decrease the risk even further. I want to integrate actually continuously. My inspiration comes mainly from the ideas of continuous integration, continuous testing, TCR, and limbo on the cheap. Actually continuously I came up with a way that drastically increased my commit frequency. I managed to create 63 commits in just 25 minutes practicing this way, where I peaked at 6 commits per minute. Yes, it was just a kata, but thatâ€™s not the important part. On many occasions literally every keystroke went live, and it was all working - covered by tests. What I did is based on the following requirements: No manual saving. The code saves itself automatically. No manual test running. The tests run continuously. They restart automatically as soon as the code changes. And they are fast. No manual commits. The code is committed automatically whenever the tests pass. No manual pulling. Changes are pulled automatically before the tests run. No manual pushing. Every commit is automatically pushed right away. Not that hard to achieve actually. Just need proper tooling and a little bit of scripting. The language Iâ€™m trying this with is Java. The right tools for the job Since I use IntelliJ, which is a great, maybe the best IDE (*cough* it became a little buggy as of recent *cough*), it saves my code automatically. So that problem is already solved. For the continuous running of the tests, I know a few options. IntelliJ offers a way to trigger the tests automatically, but itâ€™s rather slow. Then there is this old-school plugin infinitest, but I need something for the CLI so I am able to script it. And it should be really fast. Incremental compilation would be key. Gradle has it, and it is quite fast. With Gradle, I could also make the test report pretty using this test-logger plugin. I like that! Another option would be the quarkus continuous test runner, which is fairly new, and its test report is so ugly. Also, I have no idea how to customize, or script it. So I am going with Gradle for now. On top of the incremental compilation, Gradle ships with a continuous test runner in: &gt; gradle -t test But since I need more control I chose to use a little helper tool called watchexec instead. It watches for file changes and then executes a command. Like this: &gt; watchexec -e java ./gradlew test I made some tests and it is just as fast as the Gradle continuous test runner. If youâ€™d like even more control and a more complicated script, you could also use inotifywait. However, I like to keep it as simple as possible. Next, I needed to commit as soon as the tests pass. A simple bash script would do, but I like to use a modern task runner for the job. I settled with just. In case you did not know, it is a modern version of Make. And it is written in rust for whoever that may concern. The way this works is you just create a justfile and specify your tasks in it. The commit command looks like this. commit: @git add . -@git commit -am "wip" Simple and concise. To execute it you run: &gt; just commit And I do not even have to remember. My shell courteously suggests to me the available commands. The @ means that the command is not printed. By default just would abort on an error exit code, whereas the - tells it to ignore that and continue. I need this for the case where the tests pass, but I have not changed anything. For example when I add something and delete it right away. Then there would be nothing to commit, and git would throw the error, having just abort the task. I could also allow the empty commit using the allow-empty flag. But why allow an empty commit for no reason!? That would be inventory, wasteful. So here are the first commands in a justfile. commit: @git add . -@git commit -am "wip" test: clear @./gradlew test test-commit: just test just commit tdd-commit: watchexec -e java just test-commit Nice! I like it. First Try Now we are able to give it a try. Small steps. Run &gt; just tdd-commit in a terminal that stays visible next to the IDE. Write a very simple failing test; Tests fail. -&gt; The test failure is shown in the terminal immediately. Make the test pass. -&gt; Nicely formatted test report is shown immediately. Changes commit automatically. Rename the test method; Tests pass. -&gt; Changes commit automatically. Add another test; Tests fail. -&gt; I am shown the failure report. In a first attempt to make it pass I notice I cannot make it as easily. I need a preparatory refactoring first. So I disable the failing test; Tests pass again. -&gt; Changes commit automatically. I do the preparatory refactoring; Tests pass. -&gt; Changes commit automatically. I enable the failing test again; Tests fail. -&gt; I am shown the failure report. Make it pass this time; Tests pass. -&gt; Changes commit automatically. Wow, this felt smooth. During all of this, I had not manually done a single save, test run, or commit. The terminal was open on the right-hand side of my screen, and I got that feedback immediately, continuously. A meaningless commit history Letâ€™s take a look at the resulting git history. wip wip wip wip wip Whoops, thatâ€™s not very expressive. But the commits are so small and pleasant to review. Itâ€™s like a playback of every little step that was taken. It is the actual history. Honestly, I think the flow might have more value than the documentation. Still, I would like to improve on that by sneaking in descriptive empty commits every once in a while. We are used to writing git messages that describe what we did after we did it. But for this, I would like to propose a different way. I want to use a commit message to describe what is next. In other words: What my current goal is. So letâ€™s add a command to create such descriptive empty commits. goal +MESSAGE: git commit --allow-empty -m "Goal: {{MESSAGE}}" Every time I start working on a new goal, I want to write it to my git history first. Something like &gt; just goal make rover turn left. The other commit messages would stay â€˜wipâ€™ commits and thatâ€™s fine. One idea would be to use further tooling to decode some of the refactoring commits. For example: The refactoringinsight plugin. My commit history would then look something like this: wip wip wip Goal: make rover turn left wip wip wip wip Goal: make rover turn right But what about Integration? Lots of small commits on my computer are nice. But if I work in a team I need to integrate my changes to the mainline, too. So I want to pull before I run my tests, and I want to push after each commit. Itâ€™s called Continuous Integration for a reason, right? Letâ€™s add that to the justfile. integrate: git pull --rebase just test just commit git push And I think weâ€™re done. This is the complete file. It also contains a TCR task. goal +MESSAGE: git pull --rebase git commit --allow-empty -m "Goal: {{MESSAGE}}" git push commit: @git add . -@git commit -am "wip" test: clear @./gradlew test integrate: git pull --rebase just test just commit git push tdd: watchexec -e java just test ci: watchexec -e java just integrate revert: @git reset --hard &amp;&gt; /dev/null @git clean -df &amp;&gt; /dev/null @echo -e "\033[0;31m=== REVERTED ===" tcr: @just test &amp;&amp; just commit || just revert Conclusion Notice how I renamed the tdd-commit task to ci. Continuous Integration is not only about what the build server is doing, it is primarily about what we do. Coding with this script feels super smooth. It is actually continuous. Also, it was not that complicated to set up. You can probably do even better. Imagine remote pair- or mob programming with this. Hand-overs could not be easier. You just exchange the screen-sharing while the tests pass. And thatâ€™s it. Probably some people are already working this way? Let me know!]]></summary></entry><entry><title type="html">Running a Company Coding Dojo</title><link href="http://gregorriegler.com/2022/01/07/running-a-company-coding-dojo.html" rel="alternate" type="text/html" title="Running a Company Coding Dojo" /><published>2022-01-07T00:00:00+00:00</published><updated>2022-01-07T00:00:00+00:00</updated><id>http://gregorriegler.com/2022/01/07/running-a-company-coding-dojo</id><content type="html" xml:base="http://gregorriegler.com/2022/01/07/running-a-company-coding-dojo.html"><![CDATA[<p>Two years ago, in 2019, I ran the first Coding Dojo at my company <a href="http://www.ebcont.com">EBCONT</a>. 
Corona wasnâ€™t a thing back then, so it happened to be an offline event that lasted 4 hours on a Thursday afternoon. 
All the brilliant people came together to practice programming and enjoyed it.
How awesome is that?</p>

<p><img src="/assets/coding-dojo/coding-dojo1-2.jpg" alt="Local Coding Dojo at EBCONT" /></p>

<p>A lot has changed since then. 
When the pandemic happened, I had to adapt and move it online.
So I decided to make it a regular remote whole-day event.
Luckily I had already collected plenty of experience from my friends at the <a href="https://www.softwerkskammer.org/groups/wien">Vienna Software Crafts Community</a> where we also run Coderetreats.</p>

<p>The EBCONT Coding Dojo turned out to be a small success story.
When I started it, I had approximately ten people join, many of which became regular attendees.
But lately, there was a small hype around the event.
People liked it so much that they came up with the idea to create a Coding Dojo T-Shirt and shoot a group photo with it.
Of course, we did so.
I had 25 employees join in the latest event, and it was a lot of fun.</p>

<p><img src="/assets/coding-dojo/ebcont_remote_dojo.jpg" alt="Local Coding Dojo at EBCONT" /></p>

<p>Again, take a closer look at these sweet t-shirts! :-)</p>

<p><img src="/assets/coding-dojo/sweet-tshirts.jpg" alt="EBCONT Coding Dojo T-Shirts" /></p>

<h2 id="coding-dojo">Coding Dojo???</h2>
<p>So what is a Coding Dojo, how do I do it, and what can you take away from my experience?
The term <a href="https://en.wikipedia.org/wiki/Dojo">Dojo</a> originates in Japan and stands for a training facility where they perform katas, 
choreographed patterns of martial art movements designed for practice.</p>

<p>A <a href="https://codingdojo.org/WhatIsCodingDojo/">Coding Dojo</a> is a similar thing.
We just perform coding katas.
It is a great opportunity to practice technical skills like TDD, design, and refactoring.
Invaluable fundamentals that are mostly not taught in school.
They are left behind the things that turn out to have higher demand: Frameworks and tools.</p>

<p>Under pressure, we naturally fall back to old and maybe poor habits, even though it leads to worse results.
So we take our time to practice and get comfortable with better programming techniques and to be confident to apply them when it counts.
While the traditional Coding Dojo is a short ~2-hour event, the one I do lasts almost a whole day.</p>
<blockquote>
  <p>The Coding Dojo creates space for developers to practice the fundamentals of programming, away from the pressure of getting things done.</p>
</blockquote>

<h2 id="but-why-not-a-full-day">But why not a full day?</h2>
<p>An intense full-day practice event can become tiring in my experience.
Closing just a little bit sooner leaves everybody more energy for the final retrospective and the evening after the event.
There are similar whole-day events in the name of Coderetreat and Mobretreat.
The classical Coderetreat has the notion of throwing away your code after a timeboxed session and starting from scratch with a different pair.
So you donâ€™t finish, but get to see many different perspectives within a short time - quite intense.
Thatâ€™s a little different from what I do.
I like to provide the participants the opportunity to dive deeper into a kata. 
So we stay within the same teams and kata throughout the day.
This reduces the relative amount of setup time, which allows us to get more coding done.</p>

<h2 id="the-dojo-plan">The Dojo plan</h2>
<p>I decide on the topic and kata in advance, taking the attendeesâ€™ skill levels into account.
Before the event, I send them information about what weâ€™ll be working on.
The Dojo starts with a short welcome where we have a few minutes of small talk before the intro session begins.
In the intro session, we discuss the topic and kata.
I like to walk over a minimum of the theory that I believe everybody should know.
One effective way to do this is to keep asking questions so they provide the answers themselves.
At the end of the intro session, we form the teams whose be working together in the following coding sessions.</p>

<h3 id="balancing-teams">Balancing teams</h3>
<p>I want less experienced people to learn from more experienced people.
But that doesnâ€™t mean more experienced ones wonâ€™t learn. 
They deepen their understanding as they communicate their ideas.
Curious participants may even challenge their thinking and help them to refresh or even reset.
So I like to balance the skill levels among the teams while also taking into account their desired programming language. 
The tool I use <a href="https://www.gather.town/">Gather-Town</a> helps me with that.</p>

<blockquote>
  <p>Gather-Town is a remote video conference tool that works like a multiplayer version of Zelda.
You can move around on a 2d map and talk to people in your vicinity.
It creates that feeling of meeting somebody at a conference in the hallway again, just online.
And it allows us to split up and go to different rooms.
Also, it gives me the freedom to customize the map.
I use an altered version of a map that Christian Haas once made for Viennas Global Day of Coderetreat.</p>
</blockquote>

<p>I ask the people to assess their abilities and to take a position in the room that matches their confidence to work on the given kata.
Standing on the right end of the room means <em>â€œvery confidentâ€</em> and the left end means <em>â€œIâ€™m lostâ€</em>.
The rest of the spectrum is in between.
This creates an overview that makes it fairly easy to form balanced teams.
In my opinion, the optimal team size is 3, but 4 works too.
For bigger teams, you might want to assign a designated facilitator.</p>

<h4 id="tip-assign-a-facilitator-for-a-team">Tip: Assign a facilitator for a team</h4>
<p>It is not possible for me as a single person to facilitate the programming in every team.
Especially when the people are not used to collaborative coding it makes sense to assign a designated facilitator.
The responsibility of this person is to provide just enough guidance for the team to work well together.
This can be anyone who knows a bit of mob programming. 
The role can be rotated so that everybody gets the chance to contribute.
When the team is small and most people are already used to this, a facilitator might not be necessary.</p>

<h3 id="coding-sessions--retrospectives">Coding sessions &amp; retrospectives</h3>
<p>Typically we manage to have three coding sessions, each of which is followed by a short retrospective.
In these retros, we discuss anything interesting.
How we feel, what we discovered and learned, and how we approached the exercise.
We might also share and review the code we had written so far.</p>

<p>The first session always includes setup, which is the time spent until the team starts coding together in some way.
Somehow, setup always takes a fair amount of time - regardless of how well prepared you are.
The goal is to minimize this time and maximize coding time.
There are lots of ways to code together quickly, and you probably already have some in mind.
However, I would like to share some ways with you I found work well.</p>

<h4 id="1-single-driver-mode">#1 Single Driver Mode</h4>
<p>A way to get to code quickly is to have just a single person who already has a setup prepared to share their screen.
The downside of this is the risk of other people falling behind due to inactivity.
The avoid that, the person sharing should behave as a passive driver while the other people make decisions and rotate the navigator role.
I prefer when everybody gets to drive, but this usually takes more setup time.</p>

<h4 id="2-cyber-dojo">#2 Cyber-Dojo</h4>
<p><a href="http://www.cyber-dojo.org">Cyber-Dojo.org</a> works well for TDD katas, as it allows you to create and share a browser-based setup for any language in no time.
However, it wonâ€™t provide you with all the conveniences your IDE does.
Things like continuous compilation, autocompletion, automated refactoring, and so on are not available.</p>

<h4 id="3-virtual-dev-environment">#3 Virtual dev environment</h4>
<p>Another way to get to code together quickly is to join the same virtual development environment.
It could be a virtual machine running in the cloud where everything is already set up. 
People would connect to it through some remote desktop software.
I prepared something like this, where I can spawn an immutable Linux dev system on Azure: <a href="https://github.com/gregorriegler/remdev-azure">Remdev on Azure</a></p>

<h3 id="a-typical-schedule">A typical schedule</h3>
<p>This is what my typical schedule would look like:</p>

<ul>
  <li><strong>08:50 - 09:10</strong> - Welcome</li>
  <li><strong>09:10 - 09:40</strong>	- Theory, Details</li>
  <li><strong>09:40 - 10:50</strong>	- First Coding Session</li>
  <li><strong>10:50 - 11:00</strong>	- Short Break</li>
  <li><strong>11:00 - 12:30</strong>	- Second Coding Session</li>
  <li><strong>12:30 - 13:30</strong>	- Lunch Break</li>
  <li><strong>13:30 - 14:50</strong>	- Third Coding Session</li>
  <li><strong>14:50 - 15:30</strong>	- Retro</li>
</ul>

<p>Coding sessions already include 10-20 minutes of retro time.
While itâ€™s not a big deal to be a little late in the schedule, I want to nail the 1-hour lunch break.
This allows people to plan and spend that time with their families.</p>

<h2 id="my-role-as-a-facilitator">My role as a facilitator</h2>
<p>As a facilitator, I am not there to actively perform katas. 
Instead, my job is to make sure that every participant gets the chance to learn and practice.
So I am merely the organizer and enabler.
I watch out that we keep the schedule (which Iâ€™m terrible at) and mostly try to get out of the peoplesâ€™ way.
Also, Iâ€™m there to help the participants when they get stuck or have questions.
But this doesnâ€™t mean Iâ€™m not learning.
Quite the opposite is true.
I learn a lot as I get to see amazing ideas, experience new tech, observe sociotechnical patterns, discover and rediscover non-obvious details.</p>

<p>During the coding sessions, I switch from team to team and observe what theyâ€™re up to. 
This works well with Gather-Town as I can literally walk from room to room.
Occasionally I see things I am concerned with and bring that up.
I try to do this by asking questions, sparking their creativity, and having them come up with their own solutions.
Or I may see something interesting, for example, a pattern emerge that I find worthy of a discussion, so everybody understands.
If you want to learn more about facilitation in this regard I recommend Peters <a href="https://coderetreat-facilitation.code-cop.org/">Coderetreat-Facilitation Podcast</a>.
Many of the things Iâ€™m doing are things I learned from him.</p>

<h2 id="choosing-a-katatopic">Choosing a kata/topic</h2>
<p>The Coding Dojo should be a place to practice the fundamentals.
The perfect kata is not too hard for the attendees to tackle, is small enough to finish within the event, and is one that you as a facilitator already know well.
But it doesnâ€™t have to be perfect.
As a refactoring exercise, I like the <a href="https://github.com/christianhujer/expensereport">Expense Report Kata</a> which is nice and small.
Or the <a href="https://github.com/gregorriegler/order-dispatch-refactoring-kata">Order Dispatch Kata</a> which is about <a href="https://wiki.c2.com/?TellDontAsk">Tell donâ€™t ask</a>.
As for TDD katas I liked <a href="https://en.wikipedia.org/wiki/Snake_(video_game_genre)">Snake</a>, <a href="https://codingdojo.org/kata/GameOfLife/">Game of Life</a>, or <a href="https://kata-log.rocks/mars-rover-kata">Mars Rover</a>.
But I also did completely different things.
For example, the <a href="https://docs.google.com/document/u/1/d/1TCuuu-8Mm14oxsOnlk8DqfZAA1cvtYu9WGv67Yj_sSk/pub">Elephant Carpaccio Exercise</a> which is about vertical story slicing and iteration.</p>

<h2 id="selling-your-coding-dojo">Selling your Coding Dojo</h2>
<p>If you want to start a Coding Dojo at your company, let me tell you that I think thatâ€™s awesome!
Iâ€™d recommend getting your boss to agree that it will happen during the work-day and that it will be considered work-time.
Missing know-how is a bottleneck in our industry, where the majority have less than five years of experience.
Fresh developers have to learn so many things about their tech, tools, and frameworks these days, that there is little room left for programming fundamentals like TDD and refactoring.
Some of those are mostly not taught in school either.
When people get to practice these, they become better programmers.
They get better at writing code that works, is more maintainable, and more secure, in less time.
What boss wouldnâ€™t want that?</p>

<h2 id="conclusion">Conclusion</h2>
<p>The Coding Dojo is a great and fun way to provide developers with the space they need to get better at their job.
People enjoy learning from one another in a relaxed environment like this.
Iâ€™m proud of the progress participants have made so far at my Dojo.
Feel free to contact me if you have questions, or if you would like to start a similar event.
And if you already have something like this at your company, I would love to hear about that, too.</p>]]></content><author><name>Gregor Riegler</name></author><category term="Coding Dojo" /><summary type="html"><![CDATA[Two years ago, in 2019, I ran the first Coding Dojo at my company EBCONT. Corona wasnâ€™t a thing back then, so it happened to be an offline event that lasted 4 hours on a Thursday afternoon. All the brilliant people came together to practice programming and enjoyed it. How awesome is that? A lot has changed since then. When the pandemic happened, I had to adapt and move it online. So I decided to make it a regular remote whole-day event. Luckily I had already collected plenty of experience from my friends at the Vienna Software Crafts Community where we also run Coderetreats. The EBCONT Coding Dojo turned out to be a small success story. When I started it, I had approximately ten people join, many of which became regular attendees. But lately, there was a small hype around the event. People liked it so much that they came up with the idea to create a Coding Dojo T-Shirt and shoot a group photo with it. Of course, we did so. I had 25 employees join in the latest event, and it was a lot of fun. Again, take a closer look at these sweet t-shirts! :-) Coding Dojo??? So what is a Coding Dojo, how do I do it, and what can you take away from my experience? The term Dojo originates in Japan and stands for a training facility where they perform katas, choreographed patterns of martial art movements designed for practice. A Coding Dojo is a similar thing. We just perform coding katas. It is a great opportunity to practice technical skills like TDD, design, and refactoring. Invaluable fundamentals that are mostly not taught in school. They are left behind the things that turn out to have higher demand: Frameworks and tools. Under pressure, we naturally fall back to old and maybe poor habits, even though it leads to worse results. So we take our time to practice and get comfortable with better programming techniques and to be confident to apply them when it counts. While the traditional Coding Dojo is a short ~2-hour event, the one I do lasts almost a whole day. The Coding Dojo creates space for developers to practice the fundamentals of programming, away from the pressure of getting things done. But why not a full day? An intense full-day practice event can become tiring in my experience. Closing just a little bit sooner leaves everybody more energy for the final retrospective and the evening after the event. There are similar whole-day events in the name of Coderetreat and Mobretreat. The classical Coderetreat has the notion of throwing away your code after a timeboxed session and starting from scratch with a different pair. So you donâ€™t finish, but get to see many different perspectives within a short time - quite intense. Thatâ€™s a little different from what I do. I like to provide the participants the opportunity to dive deeper into a kata. So we stay within the same teams and kata throughout the day. This reduces the relative amount of setup time, which allows us to get more coding done. The Dojo plan I decide on the topic and kata in advance, taking the attendeesâ€™ skill levels into account. Before the event, I send them information about what weâ€™ll be working on. The Dojo starts with a short welcome where we have a few minutes of small talk before the intro session begins. In the intro session, we discuss the topic and kata. I like to walk over a minimum of the theory that I believe everybody should know. One effective way to do this is to keep asking questions so they provide the answers themselves. At the end of the intro session, we form the teams whose be working together in the following coding sessions. Balancing teams I want less experienced people to learn from more experienced people. But that doesnâ€™t mean more experienced ones wonâ€™t learn. They deepen their understanding as they communicate their ideas. Curious participants may even challenge their thinking and help them to refresh or even reset. So I like to balance the skill levels among the teams while also taking into account their desired programming language. The tool I use Gather-Town helps me with that. Gather-Town is a remote video conference tool that works like a multiplayer version of Zelda. You can move around on a 2d map and talk to people in your vicinity. It creates that feeling of meeting somebody at a conference in the hallway again, just online. And it allows us to split up and go to different rooms. Also, it gives me the freedom to customize the map. I use an altered version of a map that Christian Haas once made for Viennas Global Day of Coderetreat. I ask the people to assess their abilities and to take a position in the room that matches their confidence to work on the given kata. Standing on the right end of the room means â€œvery confidentâ€ and the left end means â€œIâ€™m lostâ€. The rest of the spectrum is in between. This creates an overview that makes it fairly easy to form balanced teams. In my opinion, the optimal team size is 3, but 4 works too. For bigger teams, you might want to assign a designated facilitator. Tip: Assign a facilitator for a team It is not possible for me as a single person to facilitate the programming in every team. Especially when the people are not used to collaborative coding it makes sense to assign a designated facilitator. The responsibility of this person is to provide just enough guidance for the team to work well together. This can be anyone who knows a bit of mob programming. The role can be rotated so that everybody gets the chance to contribute. When the team is small and most people are already used to this, a facilitator might not be necessary. Coding sessions &amp; retrospectives Typically we manage to have three coding sessions, each of which is followed by a short retrospective. In these retros, we discuss anything interesting. How we feel, what we discovered and learned, and how we approached the exercise. We might also share and review the code we had written so far. The first session always includes setup, which is the time spent until the team starts coding together in some way. Somehow, setup always takes a fair amount of time - regardless of how well prepared you are. The goal is to minimize this time and maximize coding time. There are lots of ways to code together quickly, and you probably already have some in mind. However, I would like to share some ways with you I found work well. #1 Single Driver Mode A way to get to code quickly is to have just a single person who already has a setup prepared to share their screen. The downside of this is the risk of other people falling behind due to inactivity. The avoid that, the person sharing should behave as a passive driver while the other people make decisions and rotate the navigator role. I prefer when everybody gets to drive, but this usually takes more setup time. #2 Cyber-Dojo Cyber-Dojo.org works well for TDD katas, as it allows you to create and share a browser-based setup for any language in no time. However, it wonâ€™t provide you with all the conveniences your IDE does. Things like continuous compilation, autocompletion, automated refactoring, and so on are not available. #3 Virtual dev environment Another way to get to code together quickly is to join the same virtual development environment. It could be a virtual machine running in the cloud where everything is already set up. People would connect to it through some remote desktop software. I prepared something like this, where I can spawn an immutable Linux dev system on Azure: Remdev on Azure A typical schedule This is what my typical schedule would look like: 08:50 - 09:10 - Welcome 09:10 - 09:40 - Theory, Details 09:40 - 10:50 - First Coding Session 10:50 - 11:00 - Short Break 11:00 - 12:30 - Second Coding Session 12:30 - 13:30 - Lunch Break 13:30 - 14:50 - Third Coding Session 14:50 - 15:30 - Retro Coding sessions already include 10-20 minutes of retro time. While itâ€™s not a big deal to be a little late in the schedule, I want to nail the 1-hour lunch break. This allows people to plan and spend that time with their families. My role as a facilitator As a facilitator, I am not there to actively perform katas. Instead, my job is to make sure that every participant gets the chance to learn and practice. So I am merely the organizer and enabler. I watch out that we keep the schedule (which Iâ€™m terrible at) and mostly try to get out of the peoplesâ€™ way. Also, Iâ€™m there to help the participants when they get stuck or have questions. But this doesnâ€™t mean Iâ€™m not learning. Quite the opposite is true. I learn a lot as I get to see amazing ideas, experience new tech, observe sociotechnical patterns, discover and rediscover non-obvious details. During the coding sessions, I switch from team to team and observe what theyâ€™re up to. This works well with Gather-Town as I can literally walk from room to room. Occasionally I see things I am concerned with and bring that up. I try to do this by asking questions, sparking their creativity, and having them come up with their own solutions. Or I may see something interesting, for example, a pattern emerge that I find worthy of a discussion, so everybody understands. If you want to learn more about facilitation in this regard I recommend Peters Coderetreat-Facilitation Podcast. Many of the things Iâ€™m doing are things I learned from him. Choosing a kata/topic The Coding Dojo should be a place to practice the fundamentals. The perfect kata is not too hard for the attendees to tackle, is small enough to finish within the event, and is one that you as a facilitator already know well. But it doesnâ€™t have to be perfect. As a refactoring exercise, I like the Expense Report Kata which is nice and small. Or the Order Dispatch Kata which is about Tell donâ€™t ask. As for TDD katas I liked Snake, Game of Life, or Mars Rover. But I also did completely different things. For example, the Elephant Carpaccio Exercise which is about vertical story slicing and iteration. Selling your Coding Dojo If you want to start a Coding Dojo at your company, let me tell you that I think thatâ€™s awesome! Iâ€™d recommend getting your boss to agree that it will happen during the work-day and that it will be considered work-time. Missing know-how is a bottleneck in our industry, where the majority have less than five years of experience. Fresh developers have to learn so many things about their tech, tools, and frameworks these days, that there is little room left for programming fundamentals like TDD and refactoring. Some of those are mostly not taught in school either. When people get to practice these, they become better programmers. They get better at writing code that works, is more maintainable, and more secure, in less time. What boss wouldnâ€™t want that? Conclusion The Coding Dojo is a great and fun way to provide developers with the space they need to get better at their job. People enjoy learning from one another in a relaxed environment like this. Iâ€™m proud of the progress participants have made so far at my Dojo. Feel free to contact me if you have questions, or if you would like to start a similar event. And if you already have something like this at your company, I would love to hear about that, too.]]></summary></entry><entry><title type="html">Expense Report Kata - Refactor Primitive Obsession (5/5)</title><link href="http://gregorriegler.com/2021/11/15/Expense-Report-Kata-5.html" rel="alternate" type="text/html" title="Expense Report Kata - Refactor Primitive Obsession (5/5)" /><published>2021-11-15T00:00:00+00:00</published><updated>2021-11-15T00:00:00+00:00</updated><id>http://gregorriegler.com/2021/11/15/Expense-Report-Kata-5</id><content type="html" xml:base="http://gregorriegler.com/2021/11/15/Expense-Report-Kata-5.html"><![CDATA[<p>Here I am working on the Expense Report Refactoring Kata.
I like it because of its small size.
For me, the kata is about making focused refactorings. 
In this episode I have already completed the challenge of the kata, and refactor the code even further. 
I am tackling primitive obsession. 
It is the final video in the expense report series.</p>

<div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/cVCtMd73doU" frameborder="0" allowfullscreen=""></iframe></div>

<p><a href="https://github.com/gregorriegler/expensereport/tree/refactoring-video-series">The code on my GitHub</a></p>]]></content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html"><![CDATA[Here I am working on the Expense Report Refactoring Kata. I like it because of its small size. For me, the kata is about making focused refactorings. In this episode I have already completed the challenge of the kata, and refactor the code even further. I am tackling primitive obsession. It is the final video in the expense report series.]]></summary></entry><entry><title type="html">Expense Report Kata - TDD The Change &amp;amp; Gold Plating (4/5)</title><link href="http://gregorriegler.com/2021/11/08/Expense-Report-Kata-4.html" rel="alternate" type="text/html" title="Expense Report Kata - TDD The Change &amp;amp; Gold Plating (4/5)" /><published>2021-11-08T00:00:00+00:00</published><updated>2021-11-08T00:00:00+00:00</updated><id>http://gregorriegler.com/2021/11/08/Expense-Report-Kata-4</id><content type="html" xml:base="http://gregorriegler.com/2021/11/08/Expense-Report-Kata-4.html"><![CDATA[<p>Here I am working on the Expense Report Refactoring Kata.
I like it because of its small size.
For me, the kata is about making focused refactorings.
In this episode I test drive the change and add the new Lunch Type.
After that I continue refactoring the code, as there are lots of things I can still improve.</p>

<div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/2YthyLqIaqU" frameborder="0" allowfullscreen=""></iframe></div>

<p><a href="https://github.com/gregorriegler/expensereport/tree/refactoring-video-series">The code on my GitHub</a></p>]]></content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html"><![CDATA[Here I am working on the Expense Report Refactoring Kata. I like it because of its small size. For me, the kata is about making focused refactorings. In this episode I test drive the change and add the new Lunch Type. After that I continue refactoring the code, as there are lots of things I can still improve.]]></summary></entry><entry><title type="html">Expense Report Kata - Make The Change Easy (3/5)</title><link href="http://gregorriegler.com/2021/11/01/Expense-Report-Kata-3.html" rel="alternate" type="text/html" title="Expense Report Kata - Make The Change Easy (3/5)" /><published>2021-11-01T00:00:00+00:00</published><updated>2021-11-01T00:00:00+00:00</updated><id>http://gregorriegler.com/2021/11/01/Expense-Report-Kata-3</id><content type="html" xml:base="http://gregorriegler.com/2021/11/01/Expense-Report-Kata-3.html"><![CDATA[<p>Here I am working on the Expense Report Refactoring Kata.
I like it because of its small size.
For me, the kata is about making focused refactorings.
In this episode I start to refactor the code.
My refactoring is very focused so I only make those changes that make the task of adding a new ExpenseType easier.</p>

<div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/rDvQ1lF494E" frameborder="0" allowfullscreen=""></iframe></div>

<p><a href="https://github.com/gregorriegler/expensereport/tree/refactoring-video-series">The code on my GitHub</a></p>]]></content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html"><![CDATA[Here I am working on the Expense Report Refactoring Kata. I like it because of its small size. For me, the kata is about making focused refactorings. In this episode I start to refactor the code. My refactoring is very focused so I only make those changes that make the task of adding a new ExpenseType easier.]]></summary></entry><entry><title type="html">Expense Report Kata - Finish Testing (2/5)</title><link href="http://gregorriegler.com/2021/10/25/Expense-Report-Kata-2.html" rel="alternate" type="text/html" title="Expense Report Kata - Finish Testing (2/5)" /><published>2021-10-25T00:00:00+00:00</published><updated>2021-10-25T00:00:00+00:00</updated><id>http://gregorriegler.com/2021/10/25/Expense-Report-Kata-2</id><content type="html" xml:base="http://gregorriegler.com/2021/10/25/Expense-Report-Kata-2.html"><![CDATA[<p>Here I am working on the Expense Report Refactoring Kata.
I like it because of its small size. For me, the kata is about making focused refactorings. 
In this episode I finish testing the code using <a href="https://github.com/approvals/ApprovalTests.Java">ApprovalTests for Java</a>.</p>

<div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y20cEM4xZ8I" frameborder="0" allowfullscreen=""></iframe></div>

<p><a href="https://github.com/gregorriegler/expensereport/tree/refactoring-video-series">The code on my GitHub</a></p>]]></content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html"><![CDATA[Here I am working on the Expense Report Refactoring Kata. I like it because of its small size. For me, the kata is about making focused refactorings. In this episode I finish testing the code using ApprovalTests for Java.]]></summary></entry><entry><title type="html">Expense Report Kata - Intro &amp;amp; Test Skeleton (1/5)</title><link href="http://gregorriegler.com/2021/10/21/Expense-Report-Kata-1.html" rel="alternate" type="text/html" title="Expense Report Kata - Intro &amp;amp; Test Skeleton (1/5)" /><published>2021-10-21T00:00:00+00:00</published><updated>2021-10-21T00:00:00+00:00</updated><id>http://gregorriegler.com/2021/10/21/Expense-Report-Kata-1</id><content type="html" xml:base="http://gregorriegler.com/2021/10/21/Expense-Report-Kata-1.html"><![CDATA[<p>I am starting to work on the Expense Report Refactoring Kata.
I like it because of its small size. For me, the kata is about making focused refactorings. 
In this video I will walk you over the code, and create a first test skeleton using <a href="https://github.com/approvals/ApprovalTests.Java">ApprovalTests for Java</a>.</p>

<div class="embed-container"><iframe width="560" height="315" src="https://www.youtube.com/embed/DS_940tXMXQ" frameborder="0" allowfullscreen=""></iframe></div>

<p><a href="https://github.com/gregorriegler/expensereport/tree/refactoring-video-series">The code on my GitHub</a></p>]]></content><author><name>Gregor Riegler</name></author><category term="refactoring-java" /><summary type="html"><![CDATA[I am starting to work on the Expense Report Refactoring Kata. I like it because of its small size. For me, the kata is about making focused refactorings. In this video I will walk you over the code, and create a first test skeleton using ApprovalTests for Java.]]></summary></entry></feed>