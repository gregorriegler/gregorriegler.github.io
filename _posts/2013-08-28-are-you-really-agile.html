---
layout: post
title: Agility demands good Software Design
date: '2013-08-28T22:53:00.000+02:00'
author: Gregor
tags:
- XP
- TDD
- agile
- Time Pressure
- Clean Code
- Quality
- Design Patterns
modified_time: '2013-10-15T21:06:55.316+02:00'
thumbnail: http://2.bp.blogspot.com/-Qv435IVYgcY/Ug9ZKdN7nfI/AAAAAAAAAGs/PHxz3r2oMDU/s72-c/agile_vs_rush.png
blogger_id: tag:blogger.com,1999:blog-1178805312154210159.post-3716793436095604560
blogger_orig_url: http://www.beabetterdeveloper.com/2013/08/are-you-really-agile.html
---

From what i have seen, Agile Software Development is widely misinterpreted nowadays. Many people think to be agile, they just need a process like scrum to define a framework of sprints and iterations. They will sprint until they exhaust and change until they stagnate. But when you'd ask them what principles of objectoriented design are, they'd answer: "Aww yes, we use classes". And when you'd asked them if they did test driven development, they'd reply: "Ahh, this is the thing where you write tests first, isn't it?". Bottom line, people think to be agile without caring about good software design. But in the end, the most important thing is what nobody cares about. It is the agility of the software that they are producing. So if you want to be agile, a process and a mindset is not enough. You need to keep your software agile. By that i mean, you need to keep the design of the software as clean and flexible as possible, to be able to apply any future changes at minimal cost. Software design of course includes your source code. In the end, you are only as agile as your software is.<br /><br /><h3><b><span style="font-weight: bold;">Why Agile?</span></b></h3>A customer does not know what he wants in the first place. He might have a rough idea, but thats it. We cant even blame him for that, because the actual problem that we are supposed to solve is influenced by so many factors and opinions that it is almost impossible to define the best solution right away. Other than that, miscommunication will most likely make things worse. To solve these issues we start small, and deliver fast. Seeing the first result, the customer can verify if we are on track or not. He can check if we have understood, or if he himself made a bad call. He might recognize things that he hasnt thought of before. Delivering repeatedly and iteratively like that, our software will more likely be useful and accepted by the customer in the end. It will more likely lead our project to success. Of course we will have to deal with changes more often, which is why we have to make the software itself agile. In the end it is the software which needs to be changeable, not us.<br /><br /><h3>What it takes </h3>Not only does an agile development process put our software under frequent change, it also demands progress at a fast and steady pace. These facts can quickly cause our software to rot if we don't watch out. And when it does, we get slowed down even more and changes suddenly become impossible. So we'd better not forget about the most important part in agile software development: Keeping our software design as agile as possible, from high-level architecture to the very code itself. Sadly, this gets ignored way too often, and many agile projects fail because of it. They fail because they chose to go faster by neglecting quality, and they quickly rush into a deadend of code rot leading to stagnation. So please remember: It is the Software you  are building that needs to be agile in order to adapt to change defined by the customer. It is the software that needs to be agile in order to react to change with minimal effort. Rushing is not gonna make your software agile. Rushing is not gonna make YOU agile. Agility comes hand in hand with quality. And high quality is not even slow, hell no. Good quality done right makes you go even faster.<br /><br /><h3>So what is Agile Software Design? </h3>Agile Software Design is what makes your software as clean and flexible as you need it to be. It demands deliberate adoption of discovered and well established design patterns and principles of objectoriented programming. This is not easy. In fact it's hard, it's very hard. Even if you are really good and experienced at it, you might fail at some point, having to rethink many of your previous design decisions. Agile Software Design is not something that you can rush. It needs time and deliberateness. But it will pay off in the long term by making you progress at a more constant pace, which will in fact be much faster than it would be without agile design. The graphic below should clarify how quick ignorant rushing can slow you down tremendously. The graphic is not based on statistics, but on experience.<br /><a href="http://2.bp.blogspot.com/-Qv435IVYgcY/Ug9ZKdN7nfI/AAAAAAAAAGs/PHxz3r2oMDU/s1600/agile_vs_rush.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Qv435IVYgcY/Ug9ZKdN7nfI/AAAAAAAAAGs/PHxz3r2oMDU/s1600/agile_vs_rush.png" /></a><br />Agile Software Design does not end at high-level architecture. It goes on with coding. Bad code can quickly make your project more clumsy than a bad high-level design could. So the devil is in the details.<br /><br /><h3>What can you do to make your Software Design more Agile?</h3><b>From a Managers perspective?</b> Trust your Developers, don't push them. Invest in experience and expertise.<br /><br /><b>From a developers perspective?</b> First of all, learn the principles and patterns of objectoriented programming - not just in theory. Being good at those needs lots of practice. There are plenty of books for this:<br /><ul><li><a href="http://www.amazon.com/Design-Patterns-Elements-Object-Oriented-ebook/dp/B000SEIBB8">Design Patterns: Elements of Reusable Object-Oriented Software</a>,</li><li><a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445/ref=sr_1_cc_1?s=aps&amp;ie=UTF8&amp;qid=1377428897&amp;sr=1-1-catcorr&amp;keywords=agile+software+development+principles+patterns+and+practices">Agile Software Development, principles, patterns and practices</a></li></ul>and many more.<br /><br />Keep your code clean - don't underestimate this! When you are programming, you spend more time reading code, than writing code. Thus you want to minimize the time you have to read code by making it more readable. It's not a secret how clean code looks like. Take a look at <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>.<br />Other than that, use the right practices like<br /><br /><h3><b><span style="font-weight: bold;">Test Driven Development&nbsp;&nbsp;</span></b></h3>Just do it already. And if you don't know how, go on and start learning. I have heard numerous opinions of TDD where people said<br /><ul><li>"Unittests are too expensive. The Customer wont pay for that."</li><li>"Unittests slow us down, we needed to write more code in that time."</li><li>"I don't know. I'm pretty good at programming, Test-First feels needlessly hard and awkward."</li></ul>But these are just subjective opinions of people who are not experienced in TDD.<br />TDD should in fact boost your longterm development speed if you are doing it right. I have not seen a single project in my life that has been as small and simple as that it would not have taken a significant profit from a TDD approach. And i have in fact seen very simple ones. The thing is, you have to test it anyways. What else would speed up your testing more than to automate it? Also, TDD significantly reduces the amount of time you have to spend debugging which already eats up lots of your time - at least more than you'd think. Other than that those tests<br /><ul><li>become a reliable documentation of your code,</li><li>allow you to fearlessly clean up your code,</li><li>force you to think of the problem before thinking of the actual solution, which will improve your initial draft,</li><li>enforce decoupling of components, which will make your design more agile.</li></ul><h3><span style="font-weight: bold;">Pair Programming</span></h3>It's not only that 4 eyes will see more defects than 2 eyes do, but also that the transfer of knowledge is taking place. You want all developers to learn from each other to become equally valuable. And you always want more than one person to know a specific module to improve the <a href="http://en.wikipedia.org/wiki/Bus_factor">truck factor</a>. Heck yeah, some people even do <a href="http://mobprogramming.org/">mobprogramming</a> - Seriously.<br /><br /><h3><span style="font-weight: bold;">Collective Code Ownership</span></h3>Don't allow one guy to own that modules code. All code on the project must belong to everybody. Everyone is allowed and invited to view, question and improve everyones code. This might be hard for some people, and might provoke conflicts, but it is absolutely mandatory to make the code better.<br /><br /><h3><span style="font-weight: bold;">Code Reviews</span></h3>Constantly review code changes. It is the only way to stay up to date, and it will reveal code smell. You need to reveal code smell, because if you don't, you will get stuck.<br /><br /><h3><span style="font-weight: bold;">Refactoring</span></h3>Refactor often. Everytime you see something that could be refactored, you need to do it right on the spot. The earlier you do it, the more time you save. So if you do it right then, you save the most possible amount of time.<br /><br /><br /><b>tl;dr: You are just as agile as your software design, which of course includes code. High speed does not demand low quality. It doesn't work like that. In fact high quality is needed to allow high speed. Agile design evolves high quality. </b><br /><b><br /></b>